[{"title":"Java备忘录Ⅲ","url":"/2019/04/10/Java备忘录Ⅲ/","content":"\n<!--more-->\n\n---\n\n写在前面：\n\n```\n完整的安装配置Oracle数据库，似乎对于我来说真的不是一件容易的事，算来已经差不多花费了三天的时间。\n而且明显的感到是很难过的三天。\n```\n\n\n\n下面从一个代码实例中来学习,如何利用`JDBC`来连接并影响数据库的。\n\n````java\npackage no6.no61.package1;\n\nimport java.sql.Statement;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\n\npublic class ConnectTest {\n\t//数据库驱动，这些数据量基本上都是用  static  final 来加以定义\n\tprivate static final String DBDRIVER = \"oracle.jdbc.driver.OracleDriver\" ;\n\t\n    \n    //连接基本信息\n\tprivate static final String DBURL = \"jdbc:oracle:thin:@localhost:1521:SOUJIUSUBDB\" ;\n\t\n    \n    //用户名\n\tprivate static final String USER = \"system\" ;\n\t\n    \n    //密码\n\tprivate static final String PASSWORD = \"soujiu\" ;\n\n\t\n    public static void main(String[] args)throws Exception {\n\t\t//加载数据库驱动程序，此时不用实例化，这是必须的\n\t\tClass.forName(DBDRIVER);\n\t\t\n        //连接数据库 ，以上两句基本上是打开Oracle数据库的标配\n\t\t//知识点，实例化一个 Connection 类\n\t\tConnection conn = DriverManager.getConnection(DBURL,USER,PASSWORD);\n\n\t\t// 本章知识点，需要实例化 一个statement类，\n\t\tStatement stmt = conn.createStatement();\n\t\t\n        //更新功能的数据库语句\n\t\tString sql = \"insert into member(mid,name,birthday,age,note) values (2,'张三',TO_DATE('1999-10-5','yyyy-mm-dd'),24,'英俊')\";\n\t\t\n        //Select 功能的语句\n\t\tString sql2 = \"Select mid,name,birthday,age,note from member\";\n\t\t\n\t\t//执行插入sql语句\n\t\tint len =  stmt.executeUpdate(sql); \n\t\t//执行查询sql语句 \n\t\tResultSet rs = stmt.executeQuery(sql2); \n\t\t\n\t\t\n\t\t//输出插入操作对数据库的影响\n\t\tSystem.out.println(\"影响的行数是:\"+ len+\"\\n\");\n\t\t\n\t\t//利用get得到 存贮的 信息\n\t\twhile(rs.next()){\n\t\t\tint mid = rs.getInt(\"mid\");\n\t\t\tString name = rs.getString(\"name\");\n\t\t\tString birthday = rs.getString(\"birthday\");\n\t\t\tint age  = rs.getInt(\"age\");\n\t\t\tString note = rs.getString(\"note\");\n\t\t\tSystem.out.println(mid + \",\"+name+\",\"+ birthday+\",\"+ age+\",\" +note);\n\t\t}\n\t\t\n\t\t//关闭数据库\n\t\trs.close();\n\t\tstmt.close();\n\t\tconn.close();\n\t}\n}\n````\n\n\n\n总结几个要点：\n\n***连接数据库，一定要有这么几个东西： Oracle的驱动，所连接数据库的基本配置信息，用户名，密码***\n\n***加载数据库驱动程序：\t\tClass.forName(DBDRIVER);***\n\n***两个知识点： Connection 类 和 Statement 类***\n\n***执行  sql 语句使用executeUpdate() , 或者 executeQuery() 这种方法****\n\n\n\n---\n\n但是statement 这个类，我们注意到，必须要有一个冗长的既定的，sql语句，因此 已经不再使用了，所以我们引入 它的子接口： PreparedStatement\n\nPraparedStatement 可以动态的设置我们需要的语句，先使用？进行占位，然后它有很多的 set 方法，我们可以为之后我们的sql 问号标记 置入 真实值。\t\n\n```java\npackage no6.no61.package1;\n\nimport java.sql.Statement;\nimport java.sql.Connection;\nimport java.sql.Date;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\npublic class ConnectTest_2 {\n\tprivate static final String DBDRIVER = \"oracle.jdbc.driver.OracleDriver\" ;\n\tprivate static final String DBURL = \"jdbc:oracle:thin:@localhost:1521:SOUJIUSUBDB\" ;\n\tprivate static final String USER = \"system\" ;\n\tprivate static final String PASSWORD = \"soujiu\" ;\n\tpublic static void main(String[] args)throws Exception {\n\t\tClass.forName(DBDRIVER);\n\t\tConnection conn = DriverManager.getConnection(DBURL,USER,PASSWORD);\n\t\t\n\t\t\n\t\tString sql = \"insert into member(mid,name,birthday,age,note) values (3,?,?,?,?)\";\n\t\t\n\t\t\n\t\t//通过 connection 类的 preparestatement  方法 得到一个 PreparedStatement 类\n\t\tPreparedStatement stmt = conn.prepareStatement(sql);\n\t\t\n        //初始化几个数据\n        String name = \"受思维奴役的人\";\n\t\tDate birthday = new Date(0);\n\t\tint age = 18;\n\t\tString note = \"丧失了批判性\";\n\t\t\n\t\t//将上面的初始化过的几个数据设置进stmt里面\n\t\t\n\t\tstmt.setString(1,name);\n\t\tstmt.setDate(2,new java.sql.Date(birthday.getTime())); //需要特殊记忆\n\t\tstmt.setInt(3,age);\n\t\tstmt.setString(4, note);\n\t\t\n\t\t\n\t\tint len = stmt.executeUpdate();\n\t\tSystem.out.println(\"影响的行数是：\"+ len);\n\t\t\n\t\t//关闭数据库\n\t\tstmt.close();\n\t\tconn.close();\n\t}\n}\n```\n\n***因此在工程中里面大多使用`preparestatement();` ***\n\n\n\n以下三点一定记住：\n\n```java\nconnention conn = DrinerManager.getConnection( ,  , );\n\nPreparedSatement stmt  = conn.getprepareStatement(sql );\n\nResultSet rs = stmt.executeUpdate();\n\n\n```\n\n\n\n----\n\n接下来\n\n![](G:\\photo\\java&datebase.PNG)\n\n\n\n数据层要想和数据库打交道，我们必须制造出来一些可以在java程序里面运行的`简单Java类`，这种类所含的属性适合数据表相匹配的,这个类看起来就和 表很像。\n\n\n\n```java\npackage no6.no61.package1;\n\nimport java.io.Serializable;\nimport java.sql.Date;\n\n\n\n@SuppressWarnings(\"serial\")\npublic class vo implements Serializable{\n    //以下几个 属性，是和数据库里面的数据表相对应的。\n\tprivate Integer age;\t\n\tprivate String ename;\n\tprivate String job;\n\tprivate Date hiredate;\t\n\tprivate Double sal;\n\tprivate Double com;\n\tpublic Integer getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(Integer age) {\n\t\tthis.age = age;\n\t}\n\tpublic String getEname() {\n\t\treturn ename;\n\t}\n\tpublic void setEname(String ename) {\n\t\tthis.ename = ename;\n\t}\n\tpublic String getJob() {\n\t\treturn job;\n\t}\n\tpublic void setJob(String job) {\n\t\tthis.job = job;\n\t}\n\tpublic Date getHiredate() {\n\t\treturn hiredate;\n\t}\n\tpublic void setHiredate(Date hiredate) {\n\t\tthis.hiredate = hiredate;\n\t}\n\tpublic Double getSal() {\n\t\treturn sal;\n\t}\n\tpublic void setSal(Double sal) {\n\t\tthis.sal = sal;\n\t}\n\tpublic Double getCom() {\n\t\treturn com;\n\t}\n\tpublic void setCom(Double com) {\n\t\tthis.com = com;\n\t}\n}\n\n\n\n```\n\n---\n\n\n\n<font color = blue size = 9 >DAO模式实现</font>![](G:\\photo\\mydraw1.PNG)\n\n\n\n先有一个基本的表,表里面是基本的字段：\n\n```java\npackage vo;\n\nimport java.io.Serializable;\nimport java.sql.Date;\n\n//基本的表\n\n@SuppressWarnings(\"serial\")\npublic class Emp implements Serializable{\n\tprivate Integer empno;\n\tprivate String ename;\n\tprivate String job;\n\tprivate Date hiredate;\t\n\tprivate Double sal;\n\tprivate Double comm;\n\tpublic void setEmpno(Integer empno) {\n\t\tthis.empno = empno;\n\t}\n\tpublic Integer getEmpno() {\n\t\treturn empno;\n\t}\n\tpublic String getEname() {\n\t\treturn ename;\n\t}\n\tpublic void setEname(String ename) {\n\t\tthis.ename = ename;\n\t}\n\tpublic String getJob() {\n\t\treturn job;\n\t}\n\tpublic void setJob(String job) {\n\t\tthis.job = job;\n\t}\n\tpublic Date getHiredate() {\n\t\treturn hiredate;\n\t}\n\tpublic void setHiredate(Date hiredate) {\n\t\tthis.hiredate = hiredate;\n\t}\n\tpublic Double getSal() {\n\t\treturn sal;\n\t}\n\tpublic void setSal(Double sal) {\n\t\tthis.sal = sal;\n\t}\n\tpublic Double getComm() {\n\t\treturn comm;\n\t}\n\tpublic void setComm(Double comm) {\n\t\tthis.comm = comm;\n\t}\n}\n\n\n\n```\n\n\n\n然后是一个接口\n\n```java\npackage Dao;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport vo.Emp;\n\n/**\n * 定义emp数据层的操作标准\n * \n * 这是一个接口 \n * 这个接口 充满了一系列的动作，是对基本表进行处理的动作，谁要 实例化我这个接口，谁就要覆写方法。\n * \n * 相当于用户层到数据层的调用\n * @author 35.32\n *\n */\npublic interface IEmpDAO {\n\t//创造一个Emp 表\n\tpublic boolean doCreate(Emp vo) throws Exception;\n\t//更新一个Emp表\n\tpublic boolean doUpdate(Emp vo) throws Exception;\n\t//批量删除\n\tpublic boolean doRemoveBatch(Set<Integer> ids) throws Exception;\n\t//根据雇员编号查询指定的雇员信息\n\tpublic Emp findById(Integer id) throws Exception;\n\t//查询所有雇员信息\n\tpublic  List<Emp> findAll() throws Exception;\n\t//分页查询, 当前页，每页行数，进行模糊查询的数据列，模糊查询的关键字\n\tpublic List<Emp> findAllSplit(Integer currentpage, Integer linesize, String column ,String keywords) throws Exception;\n\t//统计查询数量\n\tpublic Integer getAllCount(String column, String keywords) throws Exception;\n}  \n\n```\n\n接着是对这个接口的实例化\n\n```java\npackage Impl;\n\nimport java.sql.Connection;\nimport java.sql.Date;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport Dao.IEmpDAO;\nimport vo.Emp;\n/**\n * 本类是对于接口的实例化，本类要手把手地 进行数据的处理\n * 从本类的名称可以看出，本类是对于 IEMPDAO 操作标准的  implements （实现）\n * 本类介于用户层，不和数据库打交道\n * \n * \n * @author 35.32\n *\n */\npublic class EmpDAOImpl implements IEmpDAO {\n\t\n\tprivate Connection conn;\n\tprivate PreparedStatement pstmt;\n\t//这个构造方法，要求你外部给我一个通往数据库的连接，这样，我才能处理数据\n\tpublic EmpDAOImpl(Connection conn) {\n\t\tthis.conn = conn;\n\t}\n\t\n\t@Override\n\tpublic boolean doCreate(Emp vo) throws Exception {\n\t\tString sql = \"insert into emp(empno,ename,job,hiredat,sal,comm) value(?,?,?,?,?,?)\";\n\t\tthis.pstmt  = this.conn.prepareStatement(sql); \t\t\t\t//pstmt挂载一个sql语句\n\t\t\n\t\t//为挂载语句设置值\n\t\tthis.pstmt.setInt(1, vo.getEmpno());\n\t\tthis.pstmt.setString(2, vo.getEname());\n\t\tthis.pstmt.setString(3, vo.getJob());\n\t\tthis.pstmt.setDate(4,new java.sql.Date(vo.getHiredate().getTime()));\n\t\tthis.pstmt.setDouble(5, vo.getSal());\n\t\tthis.pstmt.setDouble(6,vo.getComm());\n\t\t//根据挂载语句执行相应操作\n\t\treturn this.pstmt.executeUpdate() > 0;\n\t}\n\n\t@Override\n\tpublic boolean doUpdate(Emp vo) throws Exception {\n\t\tString sql = \"update from  emp set ename=? ,job=? ,hiredat=?,sal=?,comm=? where empno=? \";\n\t\tthis.pstmt  = this.conn.prepareStatement(sql); \t\t\t\t//pstmt挂载一个sql语句\n\t\t\n\t\t//为挂载语句设置值\n\t\tthis.pstmt.setString(1, vo.getEname());\n\t\tthis.pstmt.setString(2, vo.getJob());\n\t\tthis.pstmt.setDate(3,new java.sql.Date(vo.getHiredate().getTime()));\n\t\tthis.pstmt.setDouble(4, vo.getSal());\n\t\tthis.pstmt.setDouble(5,vo.getComm());\n\t\tthis.pstmt.setInt(6,vo.getEmpno());\n\t\t//根据挂载语句执行相应操作\n\t\treturn this.pstmt.executeUpdate() > 0;\n\t}\n\n\t@Override\n\tpublic boolean doRemoveBatch(Set<Integer> ids) throws Exception {\n\t\tif(ids == null || ids.size() == 0) { //没有要删除的内容\n\t\t\treturn false;\n\t\t}\n\t\tStringBuffer sql = \tnew StringBuffer();\n\t\t//请注意我们现在是要根据sets 里面的ids \n\t\t//来删除多条记录\n\t\t//只要你的码 id 在 ids 里面，那么就删除这一条记录\n\t\tsql.append(\"DELETE FROM EMP WHERE EMPNO IN (\");\n\t\t\n\t\t\n\t\t//把所有序号提取出来构造成一个完整的sql语句\n\t\tIterator<Integer> iter =  ids.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tsql.append(iter.next()).append(\",\");\n\t\t}\n\t\tsql.delete(sql.length()-1,sql.length()).append(\")\");\n\t\tthis.pstmt = this.conn.prepareStatement(sql.toString());\n\t\t\n\t\treturn  pstmt.executeUpdate() == ids.size();\n\t}\n\n\t@Override\n\tpublic Emp findById(Integer id) throws Exception {\n\t\tString sql = \"select  ename,job,hiredate,sal,comm from Emp where empno = ?\";\n\t\tthis.pstmt = this.conn.prepareStatement(sql); //sql语句挂载\n\t\tthis.pstmt.setInt(1, id);\n\t\tResultSet rs = this.pstmt.executeQuery();\n\t\tEmp emp  = new Emp();\n\t\tif(rs.next()) {\n\t\t\temp.setEname(rs.getString(1));\n\t\t\temp.setJob(rs.getString(2));\n\t\t\temp.setHiredate(rs.getDate(3));\n\t\t\temp.setSal(rs.getDouble(4));\n\t\t\temp.setComm(rs.getDouble(5));\n\t\t}\n\t\treturn emp;\n\t}\n\n\t@Override\n\tpublic List<Emp> findAll() throws Exception {\n\t\tList<Emp> emplist = new ArrayList<Emp>(); //存放多个Emp对象\n\t\t\n\t\tString sql = \"select empno,ename,job,hiredate,sal,comm from Emp \";\n\t\tthis.pstmt = this.conn.prepareStatement(sql);//挂载sql语句\n\t\tResultSet  rs = this.pstmt.executeQuery();\n\t\twhile(rs.next()) { //不用怀疑，就是这样使用的，  一个一个数据都是按顺序排列好的，所以储存着多条信息的多个字段\n\t\t\tEmp emp = new Emp();\n\t\t\temp.setEname(rs.getString(1));\n\t\t\temp.setJob(rs.getString(2));\n\t\t\temp.setHiredate(rs.getDate(3));\n\t\t\temp.setSal(rs.getDouble(4));\n\t\t\temp.setComm(rs.getDouble(5));\n\t\t\templist.add(emp);\n\t\t}\n\t\treturn emplist;\n\t}\n\n\t@Override\n\tpublic List<Emp> findAllSplit(Integer currentpage, Integer linesize, String column, String keywords) throws Exception {\n\t\tList<Emp> emplist = new ArrayList<Emp>(); //存放多个Emp对象\n\t\tString sql = \"select * from (select empno,ename,job,hiredate,sal,comm,rownum rn \"\n\t\t\t\t+ \" from  Emp \"\n\t\t\t\t+ \" where \"+ column +\" like ? and rownum <=?) temp \"\n\t\t\t\t+ \" where tmep.rn >? \";\n\t\tthis.pstmt = this.conn.prepareStatement(sql);//挂载sql语句\n\t\t\n\t\tthis.pstmt.setString(1,\"%\"+keyword+\"%\");\n\t\tthis.pstmt.setInt(2, currentpage*linesize);\n\t\tthis.pstmt.setInt(3, (currentpage-1)*(linesize ));\n\n\t\tResultSet  rs = this.pstmt.executeQuery();\n\t\twhile(rs.next()) { //不用怀疑，就是这样使用的，  一个一个数据都是按顺序排列好的，所以储存着多条信息的多个字段\n\t\t\tEmp emp = new Emp();\n\t\t\temp.setEname(rs.getString(1));\n\t\t\temp.setJob(rs.getString(2));\n\t\t\temp.setHiredate(rs.getDate(3));\n\t\t\temp.setSal(rs.getDouble(4));\n\t\t\temp.setComm(rs.getDouble(5));\n\t\t\templist.add(emp);\n\t\t}\n\t\treturn emplist;\n\t}\n\n\t@Override\n\n\tpublic Integer getAllCount(String column, String keywords) throws Exception {\n\t\tString sql = \"select count(empno)from emp where \"+ column +\"like ?\";\n\t\tthis.pstmt =  this.conn.prepareStatement(sql);\n\t\t\n\t\tthis.pstmt.setString(1, \"%\"+keywords+\"%\");\n\t\tResultSet rs = this.pstmt.executeQuery();\n\t\tif(rs.next()) {\n\t\t\treturn rs.getInt(1);\n\t\t\t\n\t\t}else\n\t\treturn 0 ;\n\t}\n\n}\n\n```","tags":["Java"]},{"title":"旧病","url":"/2019/02/02/原谅我不明白你的悲伤/","content":"\n<!--more-->\n\n 原谅我不明白你的悲伤\n\n我感到\n\n在人群中看到你时，带给我的，夜的宁静\n\n但我随即又看不到你背影\n\n我痛苦的承认，我只能够看到，人群\n\n\n\n抱歉，亲爱的\n\n我不想将你遗忘\n\n而你常在人群之中吗\n\n\n\n亲爱的\n\n我很抱歉\n\n只因我在人群中\n\n我便只能\n\n怀念你的背影\n\n忍受着\n\n逐渐消失的世界\n\n对于我的感觉\n\n\n\n\n\n亲爱的\n\n请原谅我不明白你的悲伤","tags":["话"]},{"title":"Java备忘录Ⅰ","url":"/2019/01/16/Java备忘录Ⅰ/","content":"         \n<!--more-->\n---\n\n```java\n\nclass EMP{\n\tprivate int age;\n\tprivate String name;\n\tprivate double salary;\n\t\n\tpublic EMP(int a,String n,double s){ \n\t\tage =a;\n\t\tname=n;\n\t\tsalary=s;\n\t}\n\n\tpublic void setAge(int a){ \n\t\tage=a;\n\t}\n\tpublic void setName(String n){\n\t\tname=n;\n\t}\n\tpublic void setSalary(double s){\n\t\tsalary = s;\n\t}\n\n\tpublic int getAge(){  \n\t\treturn age;\n\t}\n\tpublic String getName(){\n\t\treturn name;\n\t}\n\tpublic double getSalary(){\n\t\treturn salary;\n\t}\n\tpublic String  getInfo(){\n\t\treturn \"NAME IS:\"+name+\"\\n\"+\"AGE IS:\"+age+\"\\n\"+\"SALARY IS:\"+salary+\"\\n\";\n\t}\n}\n\n\n\n\npublic class empdemo{\n\tpublic static void main(String args[]){\n\t\t\tEMP e=new EMP(1132,\"Mr.k\",1.0);\n\t\t\tSystem.out.println(e.getInfo());\n\t\t\te.setName(\"Mike\");\n\t\t\tSystem.out.println(e.getName());\n\t}\t\n}\n```\n\n\n\n---\n\n <font color= green size=30>Java命名规范</font>\n\n* 类名称:  每个单词首字母大写   如` StudentInfo`\n* 属性名称: 第一个单词首字母大写，其余小写 如 `Studentname`\n* 方法名称: 第一个单词之外的单词首字母大写 如 `getName()`\n* 常量名称: 全部大写 如`MSG`\n* 包名称: 全部小写 如`no1.no2.XXX`\n\n---\n\n<font color = blue size=55>String初始化方法</font>\n\n关于字符串的比较，我们必须明确\n\n` =等号 只能用于数值比较`\n\n`非要让String对象用等号进行的话，比较的双方只会比较地址`\n\n我们声明一个String对象，常用两种方法\n\n第一： <FONT COLOR=RED>  String  str= \"test\"</FONT>\n\n第二：   <font color=red>String  str= new String(\"test\")</font>\n\n\n\n我们必须知道\n\n<font color = blue >第一种</font>是匿明声明，`test`此时在堆内存当中，只有一个，你仔细观察下面的*str1*和*str4*，它俩都指向了堆里面的一个匿名对象，无论有成千上万个str，只要它们都采用不加new的第一种声明方式，那么它们仅仅都是指向了同一个字符串而已，它们的地址一样，它们的内容一样，因为它们没有用new声明，堆里面，只有一个\"test\"而已\n\n <font color=blue>第二种</font>声明，和上面的匿名声明对比，意味着，每次声明都会在堆内存中，新创建一个崭新的字符串，看对比\n\n```\n\t\t\tString str1=new String(\"test1\");\n\t\t\tString str2=new String(\"test1\");\n\t\t\t\n\t\t\tSystem.out.println(str1==str2);  //结果是 false\n```\n\n结果是false意味着，即使内容不同，因为这两个对象都是用的new来创建的，所以，它们分居在堆内存的不同位置，有成千上万个new对象，堆内存中就有成千上万个字符串。\n\n\n\n* 总的来说\n\n```\n\t\t\tString str1=\"test1\";\n\t\t\tString str2=\"test1\";\n\t\t\tString str3=new String(\"test1\");\n\t\t\tString str4=new String(\"test1\");\n\t\t\tString str5=str2;\n\t\t\t\n\t\t\tSystem.out.println(str1==str2);    \t\t//true因为匿名声明，指向一模一样的地址  \n\t\t\tSystem.out.println(str3==str2);\t\t\t//false 因为两者地址不同\n\t\t\tSystem.out.println(str1.equals(str2));  //true 因为内容相同\n\t\t\tSystem.out.println(str2.equals(str3));\t//true 因为内容相同\t\n\t\t\tSystem.out.println(str3==str4);\t\t\t//false 因为地址不同\n\t\t\tSystem.out.println(str3.equals(str4));\t//true 因为内容相同\n\t\t\tSystem.out.println(str5==str2);\t\t\t//true 因为复制操作，str5和str2指向一处\n```\n\n---\n\n<font color = purple size = 40>String 的构造方法</font>\n\n\n\n```java\nString() \n          初始化一个新创建的 String 对象，使其表示一个空字符序列。\n          \nString(byte[] bytes) \n          通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。\n          \nString(byte[] bytes, Charset charset)   \n          通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。\n          \nString(byte[] ascii, int hibyte) \n          已过时。 该方法无法将字节正确地转换为字符。从 JDK 1.1 开始，完成该转换的首选方法是使用带有 Charset、字符集名称，或使用平台默认字符集的 String 构造方法。\n          \nString(byte[] bytes, int offset, int length) \n          通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。\n          \nString(byte[] bytes, int offset, int length, Charset charset) \n          通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。\n          \nString(byte[] ascii, int hibyte, int offset, int count) \n          已过时。 该方法无法将字节正确地转换为字符。从 JDK 1.1 开始，完成该转换的首选方法是使用带有 Charset、字符集名称，或使用平台默认字符集的 String 构造方法。\n          \nString(byte[] bytes, int offset, int length, String charsetName) \n          通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。\n          \nString(byte[] bytes, String charsetName) \n          通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。\n          \nString(char[] value) \n          分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。\n          \nString(char[] value, int offset, int count) \n          分配一个新的 String，它包含取自字符数组参数一个子数组的字符。\n          \nString(int[] codePoints, int offset, int count) \n          分配一个新的 String，它包含 Unicode 代码点数组参数一个子数组的字符。\n          \nString(String original) \n          初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。\n          \nString(StringBuffer buffer) \n          分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。\n          \nString(StringBuilder builder) \n          分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。\n```\n\n\n\n​\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n\n\nString 之中我们常用的函数方法\n\n**str.toCharArray( )**\n\n```\n\n\t\tString str1=new String(\"DoASYouSaid\");\n\t\tchar[] b = str1.toCharArray(); \n```\n\n**String str1 = new String(str)**\n\n```\nString str1 = new String(\"OkMan.\");\nString temp = new String(str1);\nSystem.out.println(temp);\n-> OkMan\n```\n\n---\n\n<font color=red size = 50 >类的传递</font>  \n\n```java\nclass Human{\n\tprivate int age;\n\tprivate String name;\n\tprivate Car car;\n\n\tpublic Human(int age,String name){\n\t\tthis.age = age;\n\t\tthis.name = name;\n\t}\n\tpublic void setcar(Car car){ \t//一个人有车,人里面必须有设置车的信息\n\t\tthis.car=car;\n\t}\n\tpublic Car getcar(){ \t\t\t//从人获得车信息\n\t\treturn this.car;\n\t}\n\tpublic String getinfo(){\t\t\n\t\treturn  \"Info is:\"+this.age+\" \"+this.name;\n\t}\n}\n\n\nclass Car{\n\tprivate String carname;\n\tprivate Human h;\n\tpublic Car(String carname){\n\t\tthis.carname = carname;\n\t}\n\tpublic void sethuman(Human h){\n\t\tthis.h=h;\n\t}\n\tpublic  Human gethuman(){\n\t\treturn this.h;\n\t}\n\tpublic String getinfo(){\n\t\treturn \"Info is: \"+this.carname;\n\t}\n}\n\npublic  class  ChuanDi{\n\tpublic static void main(String args[]){\n\t\tHuman h =new Human(23,\"boom\");\n\t\tCar c = new Car(\"McLaRen\");\n\t\th.setcar(c);\n\t\t System.out.println( h.getcar().getinfo() );\n\t}\n}\n```\n\n\n\n<font color = green size  =45 > 重写和重载</font >\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fzeasxqwcjj30qx0pkqea.jpg)\n\n> 这也就是说，重写体现了子类和父类之间多态的体现\n>\n> 重载是类之中的多态性的体现\n\n\n\n\n\n<font color = red  font = 30> 继承中容易的犯错 </font>\n\n```java\n class A{\n \n\tpublic void  print(){\n\t\tSystem.out.println(\"///\");\t\t\n\t}\n\t\n}\nclass B extends A{\n\n\tpublic void  print(){\n\t\tSystem.out.println(\"***\");\n\t}\n\t\n}\npublic class jicheng{\n\tpublic static  void main(String args[]){\n\t\tA a = new A(); \t\t\t//1\n\t\tB b = (B)  a;  \t\t\t//2\n\t\tb.print();\t\t\t\t//3\n\n\t\tB b2= new B();\t\t\t//4\n\t\tA a2 = (A) b2;\t\t\t//5\n\t\ta2.print();\t\t\t\t//6\n\t}\n}\n```\n\n这是个很简单直白的代码，B继承了A，并且对于A中的print()方法进行了覆写.\n\n我们的问题是:\n\n> 只有 1 2 3 行执行时，什么结果\n>\n> 只有 4 5 6 行执行时，什么结果\n\n答案是:\n\n> 一，执行错误：Exception in thread \"main\" java.lang.ClassCastException: A cannot be cast to B\n> ​       \t\t  \n>\n> 二，成功执行输出 ***\n\n原因是：\n\n>  让 a 向下转型，转型为B类 。这个时候报错，A并不知道自己的子类是什么，从上到下，无法向下转型\n>\n> 而向上转型可成功执行\n\n\n\n\n\n<font color = blue size = 40 > Usb接口简单实现</font>\n\n```java\ninterface Usb{\n\tpublic abstract void start();\n\tpublic abstract void stop();\n}\n\nclass Flash implements Usb{            //继承Usb接口以覆写方法\n\tpublic void start(){\n\t\tSystem.out.println(\"Flash start!\");\n\t}\n\tpublic void stop(){\n\t\tSystem.out.println(\"Flash stop!\");\n\t}\n}\nclass Printer implements Usb{\n\tpublic void start(){\n\t\tSystem.out.println(\"Printer start!\");\n\t}\n\tpublic void stop(){\n\t\tSystem.out.println(\"Printer stop!\");\n\t}\n}\n\nclass computer{\n\tpublic void work(Usb usb){ \t\t\t//computer只能看得到Usb\n\t\tusb.start();\n\t\tusb.stop();\n\t}\n}\n\n\npublic class Usbinterface{\n\tpublic static void main(String args[]){\n\t\tcomputer c1 = new computer();\n\t\tc1.work(new Flash());\n\t\tc1.work(new Printer());\n\t}\n}\n\n```\n\n\n\n<font color=blue size = 30> 工厂设计模式</font>\n\n```java\ninterface  Fruit{\n\tpublic void eat();\n}\nclass Apple implements Fruit{\n\tpublic void eat(){\n\t\tSystem.out.println(\"Eating Apples!\");\n\t}\n}\nclass Orange implements Fruit{\n\tpublic void eat(){\n\t\tSystem.out.println(\"Eating Orange!\");\n\t}\n}\n\nclass Factory{\n\tpublic static Fruit chose(String s){\n\t\tif(\"Apple\".equals(s)){\n\t\t\treturn new Apple();\n\t\t}else if(\"Orange\".equals(s)){\n\t\t\treturn new Orange();\n\t\t}else{\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\t\n\npublic class Factory_test{\n\tpublic static void main(String args[]){\n\t\tFruit f =  Factory.chose(\"Orange\");\n\t\tf.eat();\n\t}\n}\n```\n\n\n\n\n\n<font color = blue size  = 30> 代理设计模式</font>\n\n```java\ninterface  Subject{\n\tvoid foo();\n}\nclass RealSubject{\n\tpublic  void foo(){\n\t\tSystem.out.println(\"Fooing\");\n\t}\n}\t\nclass ProxySubject implements Subject{\n\tprivate RealSubject subject;\n\tpublic ProxySubject(RealSubject realsubject){\n\t\tthis.subject = realsubject;\n\t}\n\tpublic void Beforefoo(){\n\t\tSystem.out.println(\"Before fooing!\");\n\t}\n\tpublic void foo(){\n\t\tthis.Beforefoo();\n\t\tthis.subject.foo();\n\t\tthis.Afterfoo();\n\t}\n\tpublic void Afterfoo(){\n\t\tSystem.out.println(\"After fooing\");\n\t}\n}\n\npublic class Proxy{\n\tpublic static void main(String args[]){\n\t\tSubject s = new ProxySubject(new RealSubject());\n\t\ts.foo();\n\t}\n}\n```\n\n\n\n---\n\n\n\n<font color = blue size = 30 > Object类</font>\n\n` object`类是所有类的子类\n\n```java\nclass Book extends Object{} \t\t\t\t\t// 继承Object\n\npublic class Object_class{\n\tpublic static void main(String args[]){\n\t\tObject obja = new Book();\t\t\t \t// 向上转型\n\t\tObject objb = \"This is  a String\"; \t\t//向上转型,Object 也是 String 的父类\n\t\tBook b =(Book) obja; \t\t\t\t\t//向下转型\n\t\tString s = (String) objb;\t\t\t \t//向下转型\n\t}\n}\n```\n\n<font color = red size = 3 > Object 之toString() 方法</font>\n\n```java\nclass Book{\n\tprivate String bookname=\"\";\n\tprivate String author = \"\";\n\tpublic Book(String bookname,String author){\n\t\tthis.bookname = bookname;\n\t\tthis.author = author;\n\t}\n\tpublic String toString(){\n\t\treturn (this.author+\",\"+this.bookname);\n\t}\n}\n\nclass Book2{                       //Book2没有重写从 Object 那继承来的 toString()方法\n\tprivate String bookname=\"\";\n\tprivate String author = \"\";\n\tpublic Book2(String bookname,String author){\n\t\tthis.bookname = bookname;\n\t\tthis.author = author;\n\t}\n}\n\npublic class Object_toString{\n\tpublic static void main(String args[]){\n\t\tBook b = new Book(\"道德的谱系\",\"尼采\");\n\t\tBook2 b2 = new Book2(\"悲剧的诞生\",\"尼采\");\n\t\tSystem.out.println(b);\n\t\tSystem.out.println(b2); \t\t//因为Book2 没有重写toString(),所以打印出了地址\n\t}\n}\n\n/*\n\n尼采,道德的谱系\nBook2@6d06d69c\n\n*/\n```\n\n<font color = red size = 3 > Object 之 equals() 方法</font>\n\n```java\nclass Book{\n\tprivate String title=\"\";\n\tprivate String author=\"\";\n\tpublic  Book(String title,String author){\n\t\tthis.title = title;\n\t\tthis.author = author;\n\t}\n\n\tpublic boolean equals(Object obj){  //以下为对从Object中继承的equals()的重写\n\t\tif(!(obj instanceof Book))\n\t\t\treturn false;\n\t\tif(this == obj)\n\t\t\treturn true;\n\t\tif(obj == null)\n\t\t\treturn false;\n\t\tBook b = (Book) obj; //关键,缺少这一步必定报错。因为 title,author 是下层的属性, Object 向下转型才能取得这类特殊属性。\n\t\tif(this.title.equals(b.title) && this.author.equals(b.author) ) \n\t\t\treturn true;\n\t\treturn  false;\n\t}\n\n}\npublic class Object_equals{\n\tpublic static void main(String args[]){\n\t\tBook b1 = new Book(\"兄弟\",\"余华\");\n\t\tBook b2 = new Book(\"基督山伯爵\",\"大仲马\");\n\t\tSystem.out.println(b1.equals(b2));\n\t}\n}\n\n\n/*\n\n尼采,道德的谱系\nBook2@6d06d69c\n\n*/\n```\n\n<font color = blue size = 30> 包装数据类型</font>\n\n```java\npublic class baozhuanglei{\n\tpublic static void main(String args[]){\n\t\tString s1=\"1532\";\n\t\tint i1 = 144;\n\n\t\tInteger i2 = new Integer(1);\t //直接通过构造函数的方式进行声明\n\n\t\tInteger i3 = 1;\t \t\t\t\t //把 1 自动装箱成一个Integer类\n\t\tint i4 = i3;\t\t\t\t\t //自动拆箱\n      \tInteger i5 =i3;\t\t\t\t\t //类复制\n\n      \t//以下说明类不能直接比较 i2 i3 i5 都是类，除非这俩类是同一个类，比如 i3 和 i5\n\t\tSystem.out.println(i2==i3); \t// false \n\t\tSystem.out.println(i3==i4);\t\t// true\n\t\tSystem.out.println(i2==i4);\t\t// true \n\t\tSystem.out.println(i2==i5);\t\t// false\n\t\tSystem.out.println(i4==i5);\t  \t// true \n\t\tSystem.out.println(i3==i5);\t  \t// true 为啥这俩类比较是相等的呢?因为这俩类实际就是一个类\n        \n        \n\t    //从代表X数据类型的字符串，转换为X,使用类似 X.parseX \t的方法。\n\t\tSystem.out.println(Integer.parseInt(s1));\n\t\t//从某种数据类型转化为字符串，使用String.valueof()方法。\n        System.out.println(String.valueOf(i1));   \n\t}\n}\n```\n\n\n\n<FONT color = blue size= 30> 单例设计模式</font>\n\n> 如果想控制一个类中实例化对象的个数\t//比如我想让我定义的类无论声明几次都只有一个实例\n>\n> 需要锁定构造法方法      //在构造方法上加一个private\n>\n> 因为新对象必须要依靠构造方法，锁了构造方法意味着锁了对象\n>\n> 又因为既然只需要一个实例化对象，可以在类的内部使用 static 的方法来定义一个公共对象\n>\n> 每次 static 构造方法返回一个唯一的对象，这样外部不管有多少次调用，最终一个类只产生一个唯一的对象。\n\n例程:\n\n```java\npackage no2.no21;\nclass Singleton{\n    //final 保证了INSTANCE的值不会再改变\n    //paivate 保证了 这是个私有对象， 但外部可以通过getter方法得到\n    //static 保证了 外界每次得到的都是同一个公共的对象\n\tprivate static  final Singleton INSTANCE = new Singleton(); //私有化静态内部变量\n\t\n\tprivate Singleton(){} //构造方法私有化,保证外界不能直接实例化对象\n\tpublic static Singleton getInstance(){//getter方法，保证外界可以实例化\n\t\treturn INSTANCE;\n\t}\n    \n\tpublic void print(){\n\t\tSystem.out.println(\"Hello World!\");\n\t}\n    \n}\npublic  class SingletonTest{\n\tpublic static void main(String args[]){\n\t\tSingleton  s =null; //声明对象\n\t\ts =  Singleton.getInstance();\n\t\ts.print();\n\t}\n}\n```\n\n上面的代码稍加改进:\n\n```java\npackage no2.no21;\nclass Singleton{\n    \n\tprivate static  final Singleton INSTANCE = new Singleton();\n\t\n\tprivate Singleton(){} \n\tpublic static Singleton getInstance(){\n\t\tif(INSTANCE == null ){           \t//不同\n\t\t\tINSTANCE = new Singleton(); \t//不同\n        }\n        return INSTANCE;\n\t}\n    \n\tpublic void print(){\n\t\tSystem.out.println(\"Hello World!\");\n\t}\n    \n}\npublic  class SingletonTest{\n\tpublic static void main(String args[]){\n\t\tSingleton  s =null; \n\t\ts =  Singleton.getInstance();\n\t\ts.print();\n\t}\n}\n```\n\n<font color = blue size = 30> 多例设计模式</font>\n\n> 多例也必须 构造方法私有化\n>\n> 但是一个类 可以提供多个实例化对象\n\n例程: \n\n```JAVA\nclass Sex{\n\tprivate String title; \n\tprivate static final  Sex MALE = new Sex(\"男\");\n\tprivate static final  Sex FEMALE = new Sex(\"女\");\n\t\n\tprivate Sex(String s){\t\t\t//构造方法私有化\t\n\t\tthis.title = s;\n\t} \n\tpublic String toString(){ \t\t//重写 toString方法\n\t\treturn this.title;\n\t}\n\n\tpublic static Sex getSex(int i){  //让外部选择，从有限个静态对象中选择\n\t\tswitch(i){\n\t\t\tcase 1:\n\t\t\t\treturn MALE;\n\t\t\tcase 2:\n\t\t\t\treturn FEMALE;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}  \n\n}\npublic class Multiton{\n\tpublic static void main(String argg[]){\n\t\tSex  sex = Sex.getSex(1);\n\t\tSystem.out.println(sex);\n\t}\n}\n```\n\n\n\n<font color =red size =30 >异常捕获及处理</font>\n\n对于这个程序段\n\n```java\nSystem.out.println(\"开始计算\");\nSystem.out.println(\"计算除法\"+ (10/ 2));\nSystem.out.println(\"计算结束\");\n```\n\n可以输出\n\n```\n开始计算\n计算除法: 5\n计算结束\n```\n\n》但是，一旦被除数是零\n\n由于我们没有对异常进行处理,  程序会中断，结果变成:\n\n```\n开始计算\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n        at Yichang.main(Yichang.java:4)\n\n```\n\n意味着`发生异常的第二句以及第二句之后的句子都不执行了`\n\n如果把程序改写为\n\n```java\n\t\tSystem.out.println(\"开始计算\");\n\t\ttry{       \t\t\t\n\t\t\tSystem.out.println(\"计算除法\"+ (x/ y));\n\t\t}catch(Exception e ){\t\t\t\t\t//java对于异常的捕捉时十分方便的\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"计算结束\");\n```\n\n那么意味着 只监视 try 内容里面的代码，一旦被监视者发生错误，我们 catch 到了这个错误，使用printStackTrace() 方法将错误信息打印出来。 结果是:\n\n```c\n开始计算\njava.lang.ArithmeticException: / by zero\n        at Yichang.main(Yichang.java:15)\n计算结束\n```\n\n\n\n更加有代表性的代码是：\n\n```java\npublic class Yichang{\n\tpublic static void main(String args[]){\n\t\tSystem.out.println(\"开始计算\");\n\t\t\n        int x= Integer.parseInt(args[0]);  //用户输入 x\n        int y= Integer.parseInt(args[1]);  //用户输入 y\n\t\t\n        /*捕获*/\n\t\ttry{\n\t\t\tSystem.out.println(\"计算除法\"+ (x/ y))\n\t\t}catch(Exception e ){              \n\t\t\te.printStackTrace();\t\t//此处的报错 千变万化，取决于用户的输入有多不合理\n\t\t}\n\t\tSystem.out.println(\"计算结束\");\n\t}\n}\n```\n\n<font color  =red size = 6.4 >异常处理模板</font>\n\n```java\nclass math{\n\tpublic static int div(int x,int y) throws Exception{ //异常返回给调用者处理\n\t\tint res = 0;\n\t\tSystem.out.println(\"除法运算开始\");\n\t\tres = x /y;\n\t\tSystem.out.println(\"除法运算结束\");\n\t\treturn res;\n\t} \n\n}\npublic class Mymath{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tSystem.out.println(math.div(12,0));\n\t\t}catch(Exception e){\n\t\t \te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n结果却是!!!!! 如下\n\n```c\n除法运算开始\njava.lang.ArithmeticException: / by zero\n        at math.div(Mymath.java:5)\n        at Mymath.main(Mymath.java:14)\n```\n\n但是如果我们希望 `即使计算出错，也要把除法计算结束打印出来呢?`\n\n显然即使  *throws*  了异常，仍然需要在div方法，把计算错误的异常捕获一下子。\n\n比如下面\n\n```java\nclass math{\n\tpublic static int div(int x,int y) throws Exception{ //异常返回给调用者处理\n\t\tint res = 0;\n\t\tSystem.out.println(\"除法运算开始\");\n\t\t/*1号*/\n        try{                        \t\t//尽管throws了异常， 仍然要从根源处把异常捕获了\n\t\t\tres = x /y;  \t\t\t\t\t//下面五种方法都可以，我们还是推荐第五种\n\t\t}catch(Exception e){}\t\t\t\t//记住第五种模板\n        \n        \n        /*2号*/\n        try{\n\t\t\tres = x /y;\n        }catch(Exception e){\n            e.printStacTrace();\n        }\n        \n        /*3号*/\n        try{\n\t\t\tres = x /y;\n\t\t}catch(Exception e){}\n        finally{\n        \tSystem.out.println(\"除法运算结束\");    \n        }\n        \n        /*4号*/\n        try{\n\t\t\tres = x /y;\n        }\n        finally{\n        \tSystem.out.println(\"除法运算结束\");    \n        }\n        \n        /*5号*/\n        try{\n\t\t\tres = x /y;\n        }catch(Exception e){\n            throw e;\n        }\n        finally{\n        \tSystem.out.println(\"除法运算结束\");    \n        }\n        \n        \n\t\treturn res;\n\t} \n\n}\npublic class Mymath{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tSystem.out.println(math.div(12,0));\n\t\t}catch(Exception e){\n\t\t \te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n<font color = blue size = 10 >Java泛型</font>\n\n观察下面的危险代码:\n\n```java\npackage no2.no21.package1;\n\nclass Point{\n\tObject x;\n\tObject y;\n\t\n\tpublic void setX(Object x) {\n\t\tthis.x = x;\n\t}\n\tpublic void setY(Object y) {\n\t\tthis.y = y;\n\t}\n\tpublic Object getX() {\n\t\treturn x;\n\t}\n\tpublic Object getY() {\n\t\treturn y;\n\t}\n}\n\npublic class FanXing {\n\tpublic static void main(String[] args) {\n\t\t//设置数据\n\t\tPoint p = new Point();\n\t\tp.setX(\"东经12度\");\n\t\tp.setY(\"北纬45度\");\n\t\t//取出数据\n\t\tString x =(String) p.getX(); //从objet向下转型为Object\n\t\tString y =(String) p.getY(); //从objet向下转型为Object\n\t\tSystem.out.println(\"x坐标是: \"+ x +\",y坐标是: \"+ y);\n\t}\n}\n\n```\n\n`危险`在于，取出数据的时候，执行了向下转型的操作，这在工程中是极其容易出错的手段。\n\n所以就要引入泛型来解决这一问题.\n\n```java\npackage no2.no21.package1;\n\nclass Point<T>{ //泛型\n\t T x;\n\t T y;\n\t\n\tpublic void setX(T x) {\n\t\tthis.x = x;\n\t}\n\tpublic void setY(T y) {\n\t\tthis.y = y;\n\t}\n\tpublic T getX() {\n\t\treturn x;\n\t}\n\tpublic T getY() {\n\t\treturn y;\n\t}\n}\npublic class FanXing {\n\tpublic static void main(String[] args) {\n\t\t//设置数据\n\t\tPoint<String> p = new Point<String>();\n\t\tp.setX(\"这是哪里\");\n\t\tp.setY(\"北纬12度\");\n\t\t//取出数据\n\t\tString x = p.getX();         //注意这时候的 向下转型被取消了，这是泛型的优点\n\t\tString y = p.getY();\t\t //注意这时候的 向下转型被取消了，这是泛型的优点\n\t\tSystem.out.println(\"x坐标是: \"+ x +\",y坐标是: \"+ y);\n\t}\n}\n\n```\n\n<font color = blue>泛型接口</font>\n\n```java\npackage no2.no22.package1;\n\ninterface IMessage<T>{  //泛型接口,接口命名方式值得学习\n\tpublic void print(T t);\n}\nclass MessageImpl<T> implements IMessage<T>{\n\t@Override //覆写\n\tpublic void print(T t) {\n\t\tSystem.out.println(t);\n\t}\n}\npublic class Fanxingjiekou {\n\tpublic static void main(String[] args) {\n\t\tMessageImpl <String>  message = new MessageImpl<String>();//实例化时确定数据类型\n\t\tmessage.print(\"Hello World!\");\n\t}\n}\n\n```\n\n\n\n<font color = blue>泛型方法</font>\n\n```java\npackage no2.no22.package1;\n\npublic class Fanxingfangfa {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(fun(\"OkTomIWillBeWithYou\"));\n\t\tSystem.out.println(fun('S'));\n\t\tSystem.out.println(fun(12.3));\n\t\tSystem.out.println(fun(1));\n\t}\n\t\n\tpublic static <T> T fun(T t) { // 泛型方法 ，第一个T代表泛型，第二个T代表返回值类型\n\t\treturn t;\n\t}\n}\n\n```\n\n\n\n\n\n\n\n<font color = blue size= 20 >Anotation</font> 注释；注解\n\n```java\n@Override : 提醒是个覆写操作\n@Deprecated : 提醒这是个过期的操作\n@SupperssWarnings : 压制警告\n```\n\n<font color = blue size= 20 ></font>\n\n\n\n<font color = blue size = 10 >Lamda表达式</font>\n\n<font color = red >Lamda </font>是针对匿名内部类提出的，为了改进匿名内部类的语法而诞生的。\n\n```java\npackage no2.no22.package1;\n\n\ninterface IMessage2{           //接口\n\tpublic void print();\n}\n\npublic class Hanshushibiancheng {\n\tpublic static void main(String args[]) {\n\t\t\n        //就下面这一个方法，但是要知道因为fun方法含有 IMessage2 接口参数\n        // fun函数 功能是把接口的print功能展示出来\n        //但是 IMessage 这个接口的 print  方法是必须要复写落地的\n        //因此在使用的时候 必须 new 一个匿名的内部类，把print 方法 实例化\n        fun(\n\t\t\t new IMessage2(){         //匿名内部类\n\t\t\t\tpublic void print(){  //覆写接口print方法\n\t\t\t\t System.out.println(\"Hello World!\");}}\n\t\t\t);\n\t\t\n        \n        \n\t}\n\tpublic static void fun(IMessage2 m){     //方法之中使用到了IMessage对象\n\t\tm.print(); \n\t}\n}\n\n```\n\n通过上面的代码我们可以观察到，匿名内部类的功能仅仅是  覆写一个方法。\n\n我们使用  lamda 表达式可以改进这一做法\n\n```java\n\tfun( \n\t\t\n\t\t() -> System.out.println(\"H!\") \n\t\t\n\t\t); \n```\n\n我来解释一下\n\n***因为 要想使用fun的话，我们在下边已经给出了fun的函数体，也就是fun的功能是啥 ; 但是要想使用fun，必须要覆写 包含在fu内部的接口的  print  方法 ，如果没有接口方法的覆写，那么fun始终不会动，当很清楚的而意识到了这一点后，直接将 要覆写的内容呈现出来， 即   ( 参数 -> 覆写函数函数体 ) , 这样的话，直接了当，废话少***\n\n```java\n\tfun( \n\t\t//我们可以很清楚的知道，原来  这就是 覆写方法的样子\n\t\t() -> System.out.println(\"H!\")  \n\t\t); \n\t\t\n```\n\n\n\n<font color=blue size = 9 > 方法的引用</font>\n\n大致上形如 \n\n> X :: Y \n\n的引用就是方法的引用，其中 Y 是具体的一种方法，而 X 是拥有方法的或对象。\n\n举个例子:\n\n这个例子展现的是 类静态方法的引用\n\n```java\npackage no2.no22.package1;\n\n\ninterface imessage2<P,Q>{          //泛型接口 之中 有了一个 zhunahuan() 方法\n    //返回值类型是Q ，参数类型是P\n\tpublic Q  zhuahuan(P p);\n}\n\n\npublic class Fangfayinyong {\n\tpublic static void main(String[] args) {\n        //这里就是把 String 类的 valueOf 方法引用了一下\n        // 这个方法被赋予给 接口实例化对象【msg】 来使用，这叫接口的引用\n\t\timessage2<Integer,String> msg = String::valueOf ;  \n\t\tString s =msg.zhuahuan(111);\n\t\t\n\t\tSystem.out.println(s.replace(\"1\", \"3\"));\t\n\t}\n}\n\n```\n\n展现具体对象方法的引用\n\n```java\npackage no2.no22.package1;\n\n\ninterface I1<R>{\n\tpublic R upper();\n}\n\npublic class Fangfayinyong {\n\tpublic static void main(String[] args) {\t\n\t\t\n\t\tI1<String> exp1 = \"Hello\" :: toUpperCase; \t\t  //具体对象方法的引用\n\t\tSystem.out.println(exp1.upper());\n\t\t\n\t}\n}\n\n```\n\n 值得注意的是\n\n<font color = red >我们上述的接口内部只能够有一个方法，如果有多个方法程序就是错误的</font>\n\n为此，我们最好在接口上面加上一句话，就是\n\n> @FunctionalInterface\n\n表明这是个函数式的接口\n\n​\t\n\n展现构造方法的引用\n\n```java\npackage no2.no22.package1;\n\ninterface I2<p>{\n\tpublic p create(String t , double p);\n}\n\nclass A{\n\tString title;\n\tdouble price;\n\tpublic A(String title, double price) { // A构造方法\n\t\tthis.price= price;\n\t\tthis.title = title;\n\t}\n\tpublic String toString() {\t\t\t\t//复写 toString() 方法\n\t\treturn (\"书名是\" + this.title + \"价格是\" + this.price);\n\t}\n}\npublic class Fangfayinyong {\n\tpublic static void main(String[] args) {\n\t\t\t\t\n\t\tI2<A> exp2 = A:: new; //具体类的构造方法的引用\n\t\tA a = exp2.create(\"江南\", 13.2);\n\t\tSystem.out.println(a);\n\t}\n}\n\n\n\n\n```\n\n\n\n<font color = red size = 9 >※※ 多线程实例</font>\n\n```java\npackage no2.no23.package1;\nimport java.lang.Thread;  //导入线程类\n\nclass Mythread extends Thread{   //继承线程类\n\tprivate String name;\n\t\n\tpublic Mythread(String name){\n\t\tthis.name = name;\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tfor(int i=0;i<23;i++) {\n\t\t\tSystem.out.println(this.name + i );\n\t\t}\n\t}\n}\n\n\npublic class Jinchengyuxiancheng {\n\tpublic static void main(String[] args) {\n\t\tMythread m1 = new Mythread(\"no1\") ;\n\t\tMythread m2 = new Mythread(\"no2\") ;\n\t\tMythread m3 = new Mythread(\"no3\") ;\n\t//以下三行代码输出的是  整整齐齐的 从no1到no3的顺序打印\t\n\t\tm1.run(); //不是多线程,只是轮流执行方法\n\t\tm2.run(); //不是多线程,只是轮流执行方法\n\t\tm3.run(); //不是多线程,只是轮流执行方法\n    \t\t\n\t//以下三行代码输出的是 杂乱无序的 no1 no2 no3 的混乱排列\n\t\tm1.start(); //多线程启动,抢占资源\n\t\tm2.start(); //多线程启动,抢占资源\n\t\tm3.start(); //多线程启动,抢占资源\n\t}\n}\n\n```\n\n我们其实通过对于源码的分析可知，要想启动多线程，必须使用`Thead类的start() `方法，如果想理解请查阅\n\nThread 的 start()方法源码。\n\n***虽然 Thread 可以实现多线程的主体类定义，但是 Java 有单继承局限，为了解决单继承局限的问题，Java里面提供了 Runnable 接口 ，有一个事实我们必须明确，就是要想实现多线程 ，是必须调用  start  方法，也就是必须使用 Thread类的***\n\n***同时，Thread 类 中有一个构造方法就是***\n\n```java\npublic Thread(Runnable target)\n```\n\n***意思是，Thread 类可以接收一个 Runnable 对象，从而形成一个Thread对象 ， 这个对象再使用  start 方法就可以解决多继承下的多线程问题***\n\n范例: \n\n```java\npackage no2.no23.package1;\n\nclass MyRunnable implements Runnable{ \t\t//首先为 Thread 准备好 Runnable 类\n\tprivate String name;\t                       \n\tpublic MyRunnable(String name) {\n\t\tthis.name = name;\n\t}\n\t@Override\n\tpublic void run() {\t\t\t\t\t\n\t\tfor(int i=0;i < 23 ;i++){\n\t\t\tSystem.out.println(this.name +\"->\" + i );\n\t\t}\n\t}\n}\n\n\npublic class duoxiancheng {\n\tpublic static void main(String[] args){    \n\t\tMyRunnable  m1 = new MyRunnable(\"Jack\");   //得到实例化的 Runnable对象\n\t\tMyRunnable  m2 = new MyRunnable(\"Tom\");\t   //得到实例化的 Runnable对象\n\t\t\n\t\tnew Thread(m1).start();\t\t\t\t \t\t// 匿名的Thread对象\n\t\tnew Thread(m2).start();\t\t\t\t \t\t// 匿名的Thread对象\n\t}\n}\n\n```\n\n***你看上面的 多进程，都是纯粹的打印，而没有返回值，我们想要返回值的话应该怎样做呢？***\n\n我们使用 `callable 接口  +  FutureTask()类` 的组合完成进程流的结果的收集.\n\n```java\npackage no2.no23.package1 ;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\n\nclass Mycallable implements Callable<String>{ //Mycallable 类\n\tprivate int ticket = 10 ;\n\t@Override\n\tpublic String call() throws Exception {\n\t\t\tfor(int i=0;i<20;i++) {\n\t\t\tif(this.ticket> 0 ) {\n\t\t\t\tSystem.out.println(\"卖票， ticket= \" + this.ticket -- );\n\t\t\t}\n\t\t  }\t\n\t\treturn \"票买光了!\" ;\n\t}\n}\n\n\npublic class duoxiancheng2 {\n\tpublic static void main(String[] args) throws InterruptedException, ExecutionException {\n\t\tMycallable c1 =new Mycallable(); //callable对象\n\t\tMycallable c2 =new Mycallable(); //callable对象\n\t\t\n\t\tFutureTask<String> f1 = new FutureTask<String>(c1); //中间结果过渡层\n\t\tFutureTask<String> f2 = new FutureTask<String>(c2); // 中间结果过渡层\n\t\tnew Thread(f1).start();\t\t//进程必须开始,才可能有结果,此两句省略，将没有返回值\n\t\tnew Thread(f2).start();     \n\t\t\n\t\tSystem.out.println(f1.get());\n\t\tSystem.out.println(f2.get());\n\t}\n}\n\n```\n\n  <font color = red > callable 交给 FutureTask  交给 Thread  </font>\n\n  <font color = red > 只有 Thread 跑起来，FutureTask才可能收集到结果</font> \n\n\n\n<font color = gold> 接下来深入理解进程和线程的关系</font>\n\n```java\npackage no2.no23.package1;\n\nclass MyRunnable2 implements Runnable{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(Thread.currentThread().getName()); //输出进程流的名字\n\t}\n}\n\npublic class test153 {\n\tpublic static void main(String[] args) {\n\t\tMyRunnable2 m1 = new MyRunnable2();\n\n\t\tnew Thread(m1).start(); \n\t\tnew Thread(m1).start();\n \t\tnew Thread(m1).start();\n\t\tm1.run();  \n\n        \n        \n        /**\n\t\t * 第一次执行结果是  \n\t\t * main\n\t\t * Thread-2\n\t\t * Thread-1\n\t\t * Thread-0\n\t\t * 第二次执行结果是\n\t\t * main\n\t\t * Thread-1\n\t\t * Thread-2\n\t\t * Thread-0\n\t\t *\n\t\t * 意味着如果你不给线程命名，线程会自动命名  \t  \n\t\t * 且 m1 由于出现在main的线程之下，而下面的三个new都可以归结为是Thread下面的线程，故它们的名字是main\n\t\t */\n        \n\t} \n}\n\n```\n\n`Thread.currentThread().getName()`返回线程的名字。\n\n这样一来，线程的执行顺序就被完完整整的记录了下来。\n\n我们观察到: ***首先是main的线程，随后是 三个Thread类线程， 最重要的是，这三个线程的命名是有规律的，但是由于线程抢占资源，所以三个Thread的打印顺序不是有序的***\n\n\n\n我们可以认为 ***每当我们运行一个Java程序的时候，我们都可以在任务管理器中看到一个新的 进程 的出现，所以我们认为， 一个     Jvm  进程启动的时候，main只是这个进程的一个线程而已。***\n\n***且 Jvm 进程至少开启两个线程， 一： main线程，  二： gc线程 （垃圾收集）***\n\n\n\n\n\n<font color = blue > 进程的同步和死锁 </font>\n\n```java\npackage no2.no23.package1;\n\n\nclass MyRun implements Runnable{\n\tprivate int ticket = 5;\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i<20;i++) {\n\t\t\tif(this.ticket >0) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \" 卖票，ticket =\" +ticket--);\n\t\t}\n\t}\t\n  }\n}\npublic class test156{\n\tpublic static void main(String[] args) {\n\t\tMyRun m1 = new MyRun();\n\t\tnew Thread(m1 ,\"票贩子A\").start();\n\t\tnew Thread(m1 ,\"票贩子B\").start();\n\t\tnew Thread(m1 ,\"票贩子C\").start();\n\t}\n}\n/*\n票贩子A 卖票，ticket =5\n票贩子B 卖票，ticket =3\n票贩子B 卖票，ticket =1\n票贩子C 卖票，ticket =4\n票贩子A 卖票，ticket =2\n\n*/\n\n```\n\n\n\n\n\n对比加了延迟之后的不同步的 Thread 们\n\n\n\n```jade\npackage no2.no23.package1;\n\n\nclass MyRun implements Runnable{\n\tprivate int ticket = 5;\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i<20;i++) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif(this.ticket >0) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \" 卖票，ticket =\" +ticket--);\n\t\t}\n\t}\t\n  }\n}\npublic class test156{\n\tpublic static void main(String[] args) {\n\t\tMyRun m1 = new MyRun();\n\t\tnew Thread(m1 ,\"票贩子A\").start();\n\t\tnew Thread(m1 ,\"票贩子B\").start();\n\t\tnew Thread(m1 ,\"票贩子C\").start();\n\t}\n}\n\n/*  结果如下\n票贩子A 卖票，ticket =5\n票贩子B 卖票，ticket =4\n票贩子C 卖票，ticket =3\n票贩子C 卖票，ticket =2\n票贩子A 卖票，ticket =2\n票贩子B 卖票，ticket =2\n票贩子B 卖票，ticket =1\n票贩子A 卖票，ticket =1\n票贩子C 卖票，ticket =1\n\n*/\n\n```\n\n\n\n***上面加了延迟的相当就是，当一个进程判断到 ticket 剩一 的时候，他会进入到  for 里面去，但是还来不及改变 ticket ，又有另外一个 Thread 也判断了ticket 是1 ，也进入到 for 里面， 这两者最终会让 ticket的数值变为 -1 ，这就是不同步导致的问题。***\n\n\n\n**事到如今，我们已经能够感觉到了，要想解决不同步引起的问题，对于上面卖票事务，必须要有这样一个逻辑，即**\n\n> 当一个票贩子通过判断语句之后，其他的票贩子就不能再进行判断了，以免造成多人进入\n\nJava 中要想实现线程的同步，可以使用  `synchronized` 关键字，而这个关键字可以通过两种方式使用\n\n```java\n1. 同步代码块\n2. 同步方法\n```\n\n\n<u>同步代码块</u>\n\nJava中有四种代码块：普通代码块，构造块，静态块，同步块。\n\n观察同步代码块\n\n```java\nsynchronized(this){\n\t代码部分；    \n}\n```\n\n代码部分一次只允许一个线程进去\n\n\n\n***于是我们在上面出错的程序之中的： if() 语句那部分给括起来，表明 这一块一次只能让一个线程进去***\n\n最终改变为： \n\n```java\npackage no2.no23.package1;\n\n\nclass MyRun implements Runnable{\n\tprivate int ticket = 5;\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i<20;i++) {\n\t\t\tsynchronized(this) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif(this.ticket >0) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \" 卖票，ticket =\" +ticket--);\n\t\t}\n\t}\t\n\t}\n  }\n}\npublic class test156{\n\tpublic static void main(String[] args) {\n\t\tMyRun m1 = new MyRun();\n\t\tnew Thread(m1 ,\"票贩子A\").start();\n\t\tnew Thread(m1 ,\"票贩子B\").start();\n\t\tnew Thread(m1 ,\"票贩子C\").start();\n\t}\n}\n\n```\n\n\n\n\n\n<u>同步方法</u>\n\n\n\n上面的 给代码块加括号的行为实在是太难看了 \n\n最好是把那一块封装起来，就叫同步方法\n\n```java\npublic synchronized void fun(){\n    \ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif(this.ticket >0) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \" 卖票，ticket =\" +ticket--);\n\t\t}\n    \n}\n```\n\n这样的话，class MyRun 就可以大大简化了\n\n```java\nclass MyRun implements Runnable{\n\tprivate int ticket = 5;\n\t@Override\n\tpublic void run() {\n\t\tthis.fun();\n  }\n}\n```\n\n\n\n---\n\n<font color = red >同步实战</font>\n\n目标： \n\n设计一个生产消费模式( Producer and Customer )\n\n实现  生产者生产一件商品，消费者就消费一件商品\n\n利用多线程的初步构思如下\n\n```java\npackage no2.no23.package1;\nclass Inf{   \t\t\t\t//Inf类包含了一件商品的名字和内容，同时可以返回名字和内容\n\tprivate String title;\n\tprivate String content;\n\t\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t\tthis.title = title;\n\t}\n\tpublic void setContent(String content) {\n\t\tthis.content = content;\n\t}\n\tpublic String getTitle() {\n\t\treturn title;\n\t}\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n}\n\nclass Producer implements Runnable{ //生产者类，循环生产鞋子和裤子,我们希望生产的被Customer使用\n\tprivate Inf infp;\n\tpublic Producer(Inf infp) {\n\t\tthis.infp = infp;\n\t}\n\t\n\tpublic void run() {\n\t\tfor(int i=1;i<101;i++) {\n\t\t\tif(i%2 == 0) {\n\t\t\t\tthis.infp.setTitle(\"一号物品\");   \t\t//制造名字1\n\t\t\t\t\n\t\t\t\ttry {\t\t\t\t\t\t\t\t\t\t//制造名字后 延迟 制造内容\n\t\t\t\t\tThread.sleep(100);\t\t\t\t\t\n\t\t\t\t} catch (InterruptedException e) {\t\t\t\n\t\t\t\t\t// TODO: handle exception\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.infp.setContent(\"11111111\");\t\t\t//制造内容2\n\t\t\t}else { \n\t\t\t\tthis.infp.setTitle(\"二\");\t\t//制造名字2\n\t\t\t\t\n                try {\t\t\t\t\t\t\t\t\t\t//制造名字后 延迟 制造内容\n                   Thread.sleep(100);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO: handle exception\n\t\t\t\t}\n\t\t\t\t\n                this.infp.setContent(\"2222222\"); \t\t//制造内容2\n\t\t\t}\n\t\t}\n\t}\n\t\t\n}\n\nclass Customer implements Runnable{\n\tprivate Inf infc; \n\tpublic Customer(Inf infc){\n\t\tthis.infc = infc;\n\t}\t\n\t@Override \n\tpublic void run() {           //针对传入的Inf对象，获取它的信息\n\t\tfor(int i=1;i<100;i++) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(10);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO: handle exception\n\t\t\t}\n\t\t\tSystem.out.println(this.infc.getTitle() + \" - \" + this.infc.getContent()); //使用\n\t\t}\n\t}\n}\n\n\n\npublic class ProducerAndCostumer {\n\t\tpublic static void main(String[] args) throws Exception{\n\t\t\tInf inf = new Inf();\n\t\t\tnew Thread(new Producer(inf)).start(); //生产线程循环执行\n\t\t\tnew Thread(new Customer(inf)).start(); //消费进程循环执行\n\t\t}\n}\n\n```\n\n结果是[点击查看结果](https://paste.ubuntu.com/p/9yT6s7z54v/)\n\n原因很简单，消费者线程和生产者进程并驾齐驱，生产者刚  命名，还没有 设置内容 的时候，消费者就急着消费了，这是不同步造成的，详细的说，这是由于 **名字和内容之间存在时间间隔，名字设置好了，进入等待期，这个时候，消费者就开始消费了，然后才开始设置内容**\n\n这就是***不同步***\n\n第一个解决想法就是，把起名字和写内容 放在一块，也即是一个 同步块里面\n\n```java\npackage no2.no23.package1;\nclass Inf{\n\tprivate String title;\n\tprivate String content;\n\t\n\tpublic synchronized void set(String title, String content){ //名字和内容的设置同步了\n\t\tthis.title = title;\t\t\t\t\t\t//设置名字\t\n        \n\t\ttry {\t\t\t\t\t\t\t\t\t//加延迟\n\t\t\tThread.sleep(200);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO: handle exception\t\n\t\t}\n\n\t\tthis.content = content;\t\t\t\t\t//设置内容\n\n\t}\n\tpublic synchronized void get() {     //调用get方法可以实现信息的打印\n\t\tSystem.out.println(\"名字是\"+ this.title + \"内容是\" + this.content);\n\t}\n}\n\nclass Producer implements Runnable{ //生产者，循环生产鞋子和裤子\n\tprivate Inf infp;\n\tpublic Producer(Inf infp) {\n\t\tthis.infp = infp;\n\t}\n\t\n\tpublic void run() {\n\t\tfor(int i=1;i<101;i++) {\n\t\t\tif(i%2==1) {\n\t\t\t\tthis.infp.set(\"啦啦啦\", \"lalala\");\n\t\t\t}else {\n\t\t\t\tthis.infp.set(\"哈哈哈\", \"hahaha\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nclass Customer implements Runnable{\n\tprivate Inf infc; \n\tpublic Customer(Inf infc){\n\t\tthis.infc = infc;\n\t}\t\n\t@Override \n\tpublic void run() {\n\t\tfor(int i=1;i<100;i++) {\n\t\t\tthis.infc.get();       //没延迟，直接调用get方法打印.\n\t\t}\n\t}\n}\n\n\n\npublic class ProducerAndCustomer {\n\t\tpublic static void main(String[] args) throws Exception{\n\t\t\tInf inf = new Inf();\n\t\t\tnew Thread(new Producer(inf)).start();\t\n\t\t\tnew Thread(new Customer(inf)).start();\n\t\t}\n}\n\n```\n\n结果是[点击查看结果](https://paste.ubuntu.com/p/kZVqQ75QNK/)\n\n我们发现，虽然很好的解决了错乱问题，但是内容重复问题仍然严重，依旧无法像理想的那样，一个接着一个不同的进行打印。\n\n我们需要等待与唤醒机制解决。\n\n关于等待与唤醒机制\n\n因此，我们使用 **object**  类的 `wait()`方法\n\n```java\npackage no2.no23.package1;\nclass Inf{\n\tprivate String title;\n\tprivate String content;\n\tprivate boolean flag;\n\t// flag = true 表示可以生产\n\t// flag = fase 表示不可以生产\n\tpublic synchronized void set(String title, String content) {\n\t\t/**判断能不能生产，如果不能，证明上一波生产还没有被使用**/\n\t\tif(this.flag == false )\n\t\t\ttry {\n\t\t\t\tsuper.wait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO: handle exception\n\t\t\t}\n\t\t/****/\n\t\t\n\t\tthis.title = title;\n\t\ttry {\n\t\t\tThread.sleep(200);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO: handle exception\t\n\t\t}\n\n\t\tthis.content = content;\n\t\tthis.flag = false;\n\t\tsuper.notify(); //唤醒其他等待\n\t}\n\tpublic synchronized void get() throws InterruptedException{\n\t\tif(this.flag == true ){  //可以生产，说明还没生产呢，无法使用\n\t\t\tsuper.wait();\n\t\t}\n\t\tSystem.out.println(\"名字是\"+ this.title + \"内容是\" + this.content);\n\t\tthis.flag = true;\n\t\tsuper.notify();\n\t}\n}\n\nclass Producer implements Runnable{ //生产者，循环生产鞋子和裤子\n\tprivate Inf infp;\n\tpublic Producer(Inf infp) {\n\t\tthis.infp = infp;\n\t}\n\t\n\tpublic void run() {\n\t\tfor(int i=1;i<101;i++) {\n\t\t\tif(i%2==1) {\n\t\t\t\tthis.infp.set(\"啦啦啦\", \"lalala\");\n\t\t\t}else {\n\t\t\t\tthis.infp.set(\"哈哈哈\", \"hahaha\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nclass Customer implements Runnable{\n\tprivate Inf infc; \n\tpublic Customer(Inf infc){\n\t\tthis.infc = infc;\n\t}\t\n\t@Override \n\tpublic void run() {\n\t\t\n\n\t\tfor(int i=1;i<100;i++) {\n\t\t\ttry {\n\t\t\t\tthis.infc.get();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\npublic class ProducerAndCustomer {\n\t\tpublic static void main(String[] args) throws Exception{\n\t\t\tInf inf = new Inf();\n\t\t\tnew Thread(new Producer(inf)).start();\t\n\t\t\tnew Thread(new Customer(inf)).start();\n\t\t}\n}\n```\n\n","tags":["Java"]},{"title":"Lisp扫盲","url":"/2018/12/31/Lisp扫盲/","content":"\n通过例子了解lisp的特点\n\n<!--more-->\n\n# 1.\n\n[lisp是什么，我们为什么要用lisp](https://zh.wikipedia.org/wiki/LISP)\n\n推荐使用<font color = blackgreen size = 5> [CLISP](https://sourceforge.net/projects/clisp/)</font> 或<font color = blackgreen size = 5> [Racket](http://racket-lang.org/download/)</font> 进行clisp的练习\n\n# 2.\n\n​     Lisp拥有<font color = red>  7</font> 个基本的 运算符,大可放心,并且都易理解。\n\n​     他们是 \n\n```lisp\nquote  atom  eq  car cdr  cons cond\n```\n\n​    在详细介绍这七个运算符之前，我们先介绍list的几个小的特点\n\n##      2.1\n\n​\tlisp 不区分大小写,但 Lisp 会尽可能地，把小写转化为大写\n\n​\tlisp使用前缀表达式进行表达式的运算，这是我们并不陌生的形式\n\n ```\n\t> (+ 2)  \t\t\t\t // [ + - * / ] 四个运算要求 参与运算的数 至少有一个 \n       2\n\t> (+ 1 2 (+ 2 3)) \t     //朴素的嵌套\n\t   8\n    > (* 3 6 2)\n       36\n    > (* 3.0 6 2)\n       36.0\n\t> (/ 8 4)\n       2\n    > (/ 5 10)\n       1/2      \t\t\t //请注意，如果你没有显式的告诉lisp你用的是浮点数，它不算小数只算分数\n    > (/ 9 5.4)\n       1.6666666 \t\t\t //这样结果是小数\n    > (* 4 3 (+ 2 3(* 23 4)))\n       1164\n ```\n\n​      这一特色，这导致了Lisp所有表达式的统一性 ，只不过，有些时候我们需要认清括号的匹配。\n\n  ##  2.2 \n\n​     我们先了解几种 Lisp 的数据类型\n\n```list\n> 1 \n  1  \t\t\t\t \t\t //数字\n\n> \"___ok/'hello* \"\n  \"___ok/'hello* \"   \t\t // 字符串，双引号为字符串的一部分\n\n> '(* 2 3)232323abc \n   (* 2 3)232323ABC      \t  //引用,出现在 ' 后面的都被当作引用，这点很关键,我们后面专门介绍\n\n> (list '(* 2 3) 2 (* 2 3)) \n   ((* 2 3)26)                //list生成表，qoute引用 也就是 [ ' ], 阻止了(* 2 3) 的运算\n```\n\n\n\n## 2.3\n\n​    有了上面的准备，接下来我们来看六个基本运算符.\n\n​     **2.3.1** <font color = red >  quote </font> 的用法 \n\n ```list\n >(quote x) \n   X  \n\n>(quote (a b c)) \n   (A B C) \n \n>'(+ 1 2) \n   (+ 1 2)\n \n>'(a b c) \n   (A B C)\n\n> (list 2 3 )\n   (2 3)\n\n> '(list 2 3)\n   (list 2 3)\n ```\n\n​      `quote` 等于 `'`\n\n​      我们看到，quote的鲜明求值规则是，**什么也不做**, 跟在quote后面的东西，注定被保护，无论是想用list构造表，还是做加减乘除，只要在 `’` 之后，都会被视为一句话，而不求值.\n\n   **2.3.2**  <font color = red >atom </font>的用法\n\n​\tatom用于判断对象是否是`原子`或`空表` ,仅有这两种是原子的\n\n​        T为真，NIL为假\n\n```\n> (atom ‘a) \nT \n>  (atom ()) \nT \n>  (atom ()) \nT \n>  (atom '(a b c)) \nNIL\n```\n\n\n\n**2.3.3** <font color = red > eq</font>的用法\n\n​\t(eq x y ) 如果 x 和 y 的值是`同一个原子`或`都为空表 返回 T，否则返回 () 即NIL \n\n```\n> (eq 'a 'a) \nt \n\n> (eq 'a 'b) \nnil \n\n> (eq '() '()) \nt \n\n> (eq  '(a b) '(a b))    \nNIL                     \t//返回 nil，因为 ’(a b)不是 原子 。 \n\n```\n\n**2.3.4** <font color = red > car 和 cdr </font> 的用法\n\n​\tcar( x )  和 cdr( x )  都要求 x 是一个表，不同在于\n\n​     `car() 返回表的第一个元素,cdr()返回表除第一个剩下所有元素，如果可以以list形式返回`\n\n```list\n>(car (1 2 3))\n  报错\n\n>(car '(1 2 3)) \n  1\n\n>(cdr '(1 2 3))\n  (2 3)\n\n>(cdr (list 1 2 3))\n  (2 3)\n>(cdr '(list 1 2 3))\n  (1 2 3)\n \n>(car (cdr ‘(a b c))) \n   b \n```\n\n**2.3.5** <font color = red> cons </font>的用法\t\n\n​\tcons( x y ) 要求 y 是一个表，它返回一个由 x 和 y 连接的新表 请注意，我们要求 y 必须是一个表，但我们并没有要求 x 一定要是一个 原子或者是表.   \n\n```lisp\n>(cons  1 (2 3))\n  报错             //一定记住，一旦没有引用，Lisp就会尝试 计算这个表达式，显然它计算不出来，于是报错\n>(cons '1 '2) \n  (1 2)\n>(cons '1 '(1 2))\n  (1 1 2)\n>(cons '(2 3) '1)\n  (2 3 1)\n>()\n```\n\n**2.3.6** <font color = red> cond</font>的用法\n\n​\tcond的基本形式是  `(cond (p1 e1) (p2 e2) ... (pn en))`\n\n​\t其中 p1 到 pn 是条件，e1到 en 是结果，cond 会依次对p1到pn进行求值，直到找到第一个值为`原子t` 的p \t\t  ，那么把他对应的 e 返回.\n\n```\n> (cond\n\t    ( (eq 'a 'b) 'first)        //p1为NIL\n        ((atom 'a) 'second)       //p2为T\n\t\t((> 4 6) (+ (* 2 3) 7))   //p3为NIL\t\n  ) \n        \n  second\n```\n\n\n\n\n\n___\n\n\n\n# 3.\n\n​\t接下来是*变量和赋值*\n\n \t**3.1**\n\n​\t首先可以用 <font color = red >let</font> 进行`局部变量`的定义\n\n​\tlet的一般形式是  **let(  ( (a 1 )(b 2)(c 3))    (exps1)(exps2)...(expsn))**\n\n​\t仔细看并不复杂，括号内分为两部分\n\n​\t第一部分是多个赋值括号，全部执行;\n\n​\t 第二部分是多个处理语句，但只执行最后一个即expsn\n\n```lisp\n> (let((a 1) (b 2) (c 3 ) ) (- 2 3)(+ 23 3)(+ a 23323))\n\t23324\n```\n\n \t**3.2**\n\n​\t可以用<font color =red>defparameter</font>和<font color=red>defconsta\tnt</font>定义全局变量和全局常数\n\n​\t请注意，这里的 var左右的*，是完全可以不加的，但习惯上全局变量的名字以 * 开始和结束，习惯而已\n\n```\n>(defparameter *var* 13)                //(defparameter var 13) 也完全正确\n\t*var*                    \t\t\t// *var* 值为12\n>(defparameter *var1*(+ *var* 11.1))\n\t*VAR1*\n```\n\n​\t随后可以用<font color=red>boundp  ' </font>  来判断 对象是否是先前定义过的全局变量或常量\n\n```lisp\n(defconstant var 11)\n(defparameter var2 23)\n(boundp ' var)\n(boundp ' var2)\n\n> T\n> T\n```\n\n​\t**3.3**\n\n​\tCommom Lisp 最常用的赋值操作符是`setf`  \n\n​\t且首次通过`setf`得到值的符号将被视为全局常量.\n\n```lisp\n(setf var 22) \n> var\n> 22    //此时var是全局变量，值是 22\n\n\n(setf a (cons 'x (cons 'y nil)))\n> a\n> (X Y)   //此时a是全局的列表 值是(X Y)\n\n\n (setf (car a) 2)\n> a\n> (2 Y)\n```\n\n\n\n# 4.\n\n**关于占位符以及格式**\n\n\n\n终于到了Lisp语言的输出和输入\n\n类似`C`语言的`printf`，Lisp进行输出时，要通过format关键字\n\n类似`C`语言的`%d,%c`，Lisp进行替换时，要通过~A，~S , ~D 等关键字,下面进行总结\n\n>~%: 换行\n>\n>~A : 该位置用后面的参数替换\n>\n>~S : 该位置用后面的参数替换，~S除了可以实现~A的功能外，还可用于字符串替换\n>\n>~X : 整数控制符 ,  打印十六进制\n>\n>~D : 整数控制符，打印十进制\n>\n> ~O: 整数控制符，打印八进制\n>\n>~B : 整数控制符，打印二进制\n>\n>~R : 整数控制符，打印英文基数\n>\n>~E : 浮点数指数格式打印\n>\n>~F : 浮点数定点格式打印\n>\n>~G :浮点数浮点格式打印\n>\n>~$ : 浮点数定点结合方式打印\n\n下面给出几个实例:\n\n\n\n> (format \"1 + 2 = ~A\"   3)\n>\n> ”1 + 2 = 3“\n>\n> (format \"~X\" 544)\n>\n> \"220\"\n>\n> (format \"~A ~S is the end of the world\"  3  'banana')\n>\n> \"3 banana is the end of the world\"\n>\n> (format nil\"~D ~B ~X ~O ~R\" 23 23  23 23 23)\n>\n> \"23 10111 17 27 twenty-three\"\n\n值得注意的是 ，在上 述例子中， format 的第 一个参数为 nil 时，打印 执行后返回 值不 出现 nil ；而 参数为 t 时，打印 执行后返回 值出现 nil ，这就是 所谓 Lisp 的副 产品 ， 我们 在 以后 的 章节将 详细 介绍 。\n\n\n\n`换行: `   \n\n* `~n%` 和 `~n&`    意为换n行， `~I `意为制表键\n\n```lisp\n(format nil \"I  ~2%Am ~2&Ok  ~I howareyou\")\n\"I\n\nAm\n\nOk   howareyou\"\n```\n\n \n\n\n\n\n\nCommon Lisp 的标准 输入运 算符是 read 。通 常是 从 toplevel 获得 输入 。需要注 意的是 ，使用 read 命令，系统将 一直等待用 户输入直到 用 户输入回车 符为 止。\n\n```lisp\n> (SETF A (READ))12 \n12 \n> A \n12 \n\n\n> (SETF B (READ))Lisp \nLisp \n> B \nlisp\n```\n\n# 5.\n\n关于条件语句\n\n\n\n**5.1**\n\n一般来说 ，函数名以字母   ` p `  结尾的 lisp函数, 都用于 <font color =red>检验对象具有某种属性</font>\n例如 :\n\n`symbolp\nlistp\nkeywordp\nboundp\nfboundp\nnumberp\ntypep\noddp\nevenp\nzerop`\nNull 可用于 判断 一个表是 否是空表。\n\n```\n>  (boundp '*var*)\nT \n> (symbolp 'abc)\nT \n> (listp '(a b c))\nT \n> (fboundp 'cons) \nT \n>  (numberp 23) \nT \n>  (typep 12 'integer) \nT \n>  (typep 'area 'symbol) \nT \n> (null nil) \nT \n> (null ()) \nT \n```\n\n**5.2**\n\nlisp还支持<font color = green>and , or , not </font>三个关键字\n\n\n\nand关键字后面跟着几个表达式，<font color =red>当且仅当 全部的表达式都是正确的，此时结果返回最后一个正确的表达式的值</font>\n\n> (and (> 2 1) (+ 1 1) (numberp 's) (setf d 3) )\n>\n> > 3\n>\n> (and (* 2 2 )(setf d 3)(> 2 1))\n>\n> > T\n>\n> (and (* 2 2)(>2 3 )(setf d 3))\n>\n> > NIL\n\nor关键字后面跟着几个表达式，<font color =red>当且仅当 所有表达式至少有一个正确时成立，此时返回第一个正确的表达式</font> \n\n> (or (* 2 2)(< 1 2 ))\n>\n> > 4\n>\n> (or (> 2 3 )(* 2 2)(setf d 3))\n>\n> > 4 \n\nnot 关键字后面跟着一个表达式，<font color =red>返回和表达式真假相反的</font>(一般的代数运算都视为真)\n\n> not (>  1 2))\n>\n> > T \n\n\n\n**5.3**\n\n判断之处，怎么能够少得了 `if` 的身影呢？\n\n\n\n`if`的基本思想是，<font color = purple>对条件进行判断，倘若正确，执行第一个表达式，否则执行第二个表达式</font>\n\n同时使用   `progn`  进行多个表达式的结合，相当于是大括号。 \n\n```lisp\n > (if (> (- 3 2) 4) \n      (format nil \"~A\" 4) \n      (progn \n         (setf a (cons 2 nil)) \n         (format nil \"~A+~A=~A\" 2 3 5) \n         ))\n\n    \"2+3=5\"\n>(if (> 2 3)\n     ( * 2 3)\n     (progn \n         (format nil \"~A is \" 2)\n         (format nil \"~A!\" 3)\n      )\n )\n\"3!\"\n```\n\n\n\n# 6.\n\n**循环以及循环体**\n\n\n\n*6.1*\n\n `do`循环\n\n do循环的基本形式是: \n\n```lisp\n(do ((变量名 变量初值 (变量变化语句)))\n      (结束条件 返回值)\n       循环主体)\n```\n\n应用到一个实际需求上，我们要 得到 从`1到10所有的数的平方`，即通过循环得到\n\n```lisp\n (let ((b nil))   //初始化\n      (do   ((a 1 ( 1+ a ))) \t\t//变量变化语句 \n          ((> a 10)b)  \t\t\t\t//循环控制条件\n          (setf b (cons(* a a)b)) \t//循环执行语句\n      )\n )\n\n//结果\n(100 81 64 49 36 25 16 9 4 1)\n```\n\n\n\n*6.2*\n\n`dolist` 循环\n\ndolist循环的基本形式是:\n\n```lisp\n(dolist (循环变量 元素列表 返回值) \n\t需要执行的语句 \t   \n)\n```\n\n实例：计算从 1 到 10 的平方根的和\n\n```lisp\n(let  ((b '(1 2 3 4 5 6 7 8 9 10)) (c 0)  d ) \n \t(dolist (v b c) \n        (setf d (sqrt v)) \n        (setf c (+ c d ))\n\t )\n )\n//结果\n22.468277\n```\n\n# 7.\n\n**函数的定义**\n\n*7.1*\n\n函数的定义很简单，形式如下：\n\n```lisp\n(defun 函数名(参数列表)\n\t(\n\t函数的功能\n\t)\n)\n```\n\n实例：\n\n```lisp\n//我定义了一个函数，功能就是完成乘方\n\n(defun myafun(v)\n\t(* v v)\n)\nMYAFUN\n\n> (myafun 2)\n  4\n```\n\n\n\n*7.2*\n\n看一个复杂的例子\n\n功能是完成两个矩阵的笛卡儿积\n\n```lisp\n面再 给出一个函数的例 子。\n >  (defun discarets(list1 list2)\n \t\t(let ((a nil)(rst nil))  \t\t//初始化\n \t\t\t(dolist (v list1 rst)\t\t//行\n \t\t\t\t(dolist (u list2)       //列           \n \t\t\t\t\t(setf a (list u v)  //取两个元素进行搭配                           \n\t\t\t\t\t\t rst (cons a rst)))))) //将每一对搭配好的 组合为最终结果 \n\n\nDISCARETS \n\n\n>   (DISCARETS '(1 2 ) '(a b c)) \n\n((C 2) (B 2) (A 2) (C 1) (B 1) (A 1)) \n\n```\n\n\n\n","tags":["lisp"]},{"title":"机器学习日记_2","url":"/2018/11/25/机器学习日记(二)/","content":"\n![](https://wx4.sinaimg.cn/mw690/6c3e6b13gy1fxjkkti8zwj21900u0qoe.jpg)\n\n<!--more-->\n\n\n\n------\n\n\n\n# 第一个机器学习算法\n\n<font color=blue size=5>Linear regression with one variable</font>【一元线性回归】\n\n\n\n什么是一元变量线性回归？\n\n```\n回归分析只涉及到两个变量的，称一元回归分析。一元回归的主要任务是从两个相关变量中的一个变量去估计另一个变量，被估计的变量，称因变量，可设为Y；估计出的变量，称自变量，设为X。回归分析就是要找出一个数学模型Y=f(X)，使得从X估计Y可以用一个函数式去计算。当Y=f(X)的形式是一个直线方程时，称为一元线性回归。这个方程一般可表示为Y=A+BX。根据最小平方法或其他方法，可以从样本数据确定常数项A与回归系数B的值。A、B确定后，有一个X的观测值，就可得到一个Y的估计值。回归方程是否可靠，估计的误差有多大，都还应经过显著性检验和误差计算。有无显著的相关关系以及样本的大小等等，是影响回归方程可靠性的因素\n```\n\n![1543107453608](http://ww1.sinaimg.cn/large/006YPp6gly1fxk18qppzkj30px0ds4hf.jpg)\n\n\n\n举个例子来说，上面的坐标图，横轴代表房屋的面积，纵轴表示可以卖到的价钱，小王手里有一个1250单位大小的房子，他想知道这间房子可以卖多少钱？\n\n___\n\n为了解决这个问题，我们`拟合`这些数据，就是把这些离散的数据近似成为一条连续的曲线，但是你可以看到，我们通过直线拟合或二次函数拟合，这两种情况下的结果显然是不同的，那么，我们该怎样选择呢？\n\n此时此刻，我们正在解决一个`Regression problem`(回归问题)，意思就是我们想预测连续的数据输出，也就是价格。\n\n\n![1543333273119](C:\\Users\\35.32\\AppData\\Roaming\\Typora\\typora-user-images\\1543333273119.png)\n\n![1543333559831](C:\\Users\\35.32\\AppData\\Roaming\\Typora\\typora-user-images\\1543333559831.png)\n\n<font color=red> 解释: </font>\n\n```\n其实很简单\n\ntraing set : 是训练集，也就是你为了训练机器学习，而传入的样本数据集合\nm : 是数据的个数\nx ：是输入\ny ：是输出  //他俩右上角其实是个index索引而已，不是啥数学运算\nhypothesis ： 假设函数 // 就是我们假设存在一个函数h，输入个x，输出个y\nHθ(x) = θ1X + θ0 : 是假设的函数，是个看起来吓人实际上就是个线性函数，θ1是斜率，θ0是截距\n```\n\n未完待续...\n\n\n\n","tags":["MachineLearning"]},{"title":"机器学习日记_1","url":"/2018/11/24/机器学习日记(一)/","content":"\n![](https://wx1.sinaimg.cn/mw690/74cae32aly1fxbe1216zoj20u011ihdu.jpg)\n\n<!--more-->\n\n**机器学习的定义:** \n\n```\nTom Mitchell (1998) Well-posed Learning Problem:\nA computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. \n\n```\n\n`一个计算机程序从经验E中学习一些任务T和一些性能度量P，它在T上的性能，用P度量，将随着经验E的提高而提高。`\n\n比如我问你一个问题：\n\nSuppose your email program watches which emails you do or do not mark as spam, and based on that learns how to better filter spam.  What is the task T in this setting? \n\n`假设您的电子邮件程序监视您标记哪些电子邮件为垃圾邮件，并在此基础上学习如何更好地过滤垃圾邮件。在这种情况下，任务T是什么?`\n\n​     A.  Classifying emails as spam or not spam. \n\n​     B. Watching you label emails as spam or not spam. \n\n​     C. The number (or fraction) of emails correctly classified as spam/not spam. \n\n​     D. None of the above—this is not a machine learning problem.\n\n\n\n答案是`A`\n\nA选项意思是`判别一封邮件是不是垃圾邮件`，这对应着我们的我们的`任务T`\n\nB选项意思是`看你把电子邮件标记为垃圾邮件或非垃圾邮件`这对应着`经验E`\n\nC选项意思是 `正确分类为垃圾邮件/非垃圾邮件的邮件数量(或比例)`显然这是效率`P`\n\nD选项意思是`以上全错`\n\n___\n\n## 机器学习主要算法分类 ##\n\n```\nMachine learning algorithms:\n\n-Supervised learning    (监督学习)\n\n-Unsupervised learning  (无监督学习)\n\n\nReinforcement learning, recommender systems(强化学习，推荐系统)\nAlso talk about: Practical advice for applying learning algorithms(实用的应用学习算法建议)\n```\n```\n监督学习算法:\n    我们给定了一个数据集，里面都是正确的数据，supervisedlearning的目的就是，依赖这些有限的数据，给出更多的正确数据，从而完成我们估价的目的。\n```\n例如: 给了过去十年的所有肾病的病人的肾的大小，然后预测某一个大小的肾患病的几率是多大\n```\n无监督学习算法:\n    无监督学习是指从不需要人为注释的样本的分布中抽取信息\n```\n例如: 噪音分离","tags":["MachineLearning"]},{"title":"词法分析器","url":"/2018/11/11/Re-NFA-DFA-词法分析器代码/","content":"Re->NFA->DFA->词法分析器代码\n\nthompson算法\n\n```\n基于对re结构做优化(数学归纳法)\n 1.基本的re直接构造\n 2.复合的re递归构造\n递归算法，容易实现\n\n```\n\n\n\n子集构造算法\n\nhopcroft最小优化算法\n\n","tags":["complier"]},{"title":"特殊的dp","url":"/2018/11/10/特殊的dp/","content":"\n___\n\n<!--more-->\n\n已经学过了动归的我，面对一些复杂dp题目，却仍然感觉到，无从下手。\n\n我必须深刻知道，我所理解的只是皮毛罢了。\n\n针对于这个题目来讲 #[搬寝室](http://acm.hdu.edu.cn/showproblem.php?pid=1421)\n\n我被弄得很糊涂，自己只是掌握了一个空架子，几句话，几行代码，而真正的思想，可以说是根本没有触及到的。\n\n\n\n分析这个问题，题目给定了`n个物品的重量`,并提出了这样一个要求\n\n```\n给你k次(k正确)，你一次挑选两个，一次挑选两个，一共挑k次。\n要求最后，你挑的俩数差的绝对值，最后一共k个绝对值是吧，要求这些绝对值的总和最小。\n```\n\n怎么办？\n\n```c++\n每次的抉择，必定会对以后的抉择产生影响\n```\n\n如果是动态规划，要怎样想呢？\n\n1. 把所有物品排序\n2. 只选一对，从1到n的最小dp组构建出来\n3. 选两对，建立在上一步的基础上, 帅气的一个转移，我是选择这对呢，还是不选呢\n4. 以此类推\n\n这个思路的梳理，真的使人头痛，真的好菜，多做吧。\n\n```c++\n#include <iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<stack>\n#include<string>\nconst int maxn=2e3+5;\nconst int mod=1e9+7;\nconst int inf=1e9;\n#define me(a,b) memset(a,b,sizeof(a))\ntypedef long long ll;\nusing namespace std;\nint dp[maxn][maxn];\nint main()\n{\n    int n,k;\n    while(cin>>n>>k)\n    {\n        int a[maxn];me(dp,0);\n        for(int i=1;i<=n;i++)\n            scanf(\"%d\",&a[i]);\n            \n        sort(a+1,a+n+1); //sort(a+1,a+n+1)\n        for(int i=1;i<=k;i++)\n            for(int j=1;j<=n;j++)\n                if(2*i<=j)\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j-2]+(a[j]-a[j-1])*(a[j]-a[j-1]));\n                else\n                    dp[i][j]=inf;\n        cout<<dp[k][n]<<endl;\n    }\n    return 0;\n}\n```\n\n弱到无力。\n","tags":["ACM"]},{"title":"仓库","url":"/2018/11/10/仓库/","content":"\n___\n\n<!--more-->\n\n```\n#include <iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<stack>\n#include<string>\nconst int maxn=2e3+5;\nconst int mod=1e9+7;\nconst int inf=1e9;\n#define me(a,b) memset(a,b,sizeof(a))\ntypedef long long ll;\nusing namespace std;\nint dp[maxn][maxn];\n\n\n\n\n```\n___\n\nLCA离线\n\n\n\nLCA: Lowest Common Ancestors)即最近公共祖先,是指在有根树中,找出某两个结点u和v最近的公共祖先\n\n[演练及解释](https://blog.csdn.net/lw277232240/article/details/77017517) \n\n我们以  <font color=blue >poj1470Closest Common Ancestors </font>为例，结合上面的解释，进行代码展示\n\n```c++\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int MAXN=905;\nint father[MAXN],ancestor[MAXN];\nbool visit[MAXN];\nint ans[MAXN];\nvector<int> map[MAXN];//save the tree\nvector<int> query[MAXN];//save the query\nint n,t,root;\nbool indegree[MAXN];//the indegree to find the root\nint getfather(int v){//路径压缩\n    if(father[v]==v)return v;\n    return father[v]=getfather(father[v]);\n}\nvoid aunion(int u,int v){//连接两个树\n    int fv=getfather(v),fu=getfather(u);\n    father[fv]=fu;\n}\nvoid LCA(int id){\n    int len=map[id].size();\n    for(int i=0;i<len;i++){\n        int son=map[id][i];\n        LCA(son);\n        aunion(id,son);\n    }\n    visit[id]=1;\n    len=query[id].size();\n    for(int i=0;i<len;i++){\n        int son=query[id][i];\n        if(visit[son])\n            ans[father[getfather(son)]]++;\n    }\n\n}\nvoid init(){\n    int x,y,z;\n    for(int i=0;i<=n;i++){\n        map[i].clear();\n        query[i].clear();\n    }\n    memset(visit,0,sizeof(visit));\n    memset(ans,0,sizeof(ans));\n    memset(indegree,0,sizeof(indegree));\n    for(int i=0;i<=n;i++)father[i]=i;\n    for(int i=0;i<n;i++){\n        scanf(\"%d:(%d)\",&x,&y);\n        for(int j=0;j<y;j++){\n            scanf(\"%d\",&z);\n            indegree[z]=1;\n            map[x].push_back(z);\n        }\n    }\n    scanf(\"%d\",&t);\n    while(t--){//this method of the init is really clever\n        while(getchar()!='(');\n        scanf(\"%d%d\",&x,&y);\n        query[x].push_back(y);\n        query[y].push_back(x);\n    }\n    while(getchar()!=')');\n    for(int i=1;i<=n;i++)if(!indegree[i])root=i;//find the root;warning:the 0\n}\nvoid output(){\n    for(int i=1;i<=n;i++){\n        if(ans[i]!=0)\n            printf(\"%d:%d\\n\",i,ans[i]);\n    }\n\n}\nint main(){\n    while(scanf(\"%d\",&n)!=EOF){\n        init();\n        LCA(root);\n        output();\n    }\n    return 0;\n}\n```\n\n\n\n 迪杰斯特拉算法 ://我这相当于又复习一遍，有什么用呢？我不知道，只是感觉很有意思//\n\n我劝我自己先把这个视频看一遍再分析----[迪杰斯特拉演示](https://www.youtube.com/watch?v=RFEqcXSo_Zg)\n\n```c++\n#include<queue>\n#include<string.h>\n#include<stdio.h>\n#include<iostream> \n#include<bits/stdc++.h>\n\n\nusing namespace std;\n\nconst int inf=0x3f3f3f3f;\nconst int maxn=1005;\ntypedef pair<int ,int >pii;\nint n;\nint dist[maxn+5];\nint cost[maxn+5];\nint graph[maxn][maxn];\nint price[maxn][maxn];\n\n\nint Dijkstra(int start){\n\tpriority_queue<pii,vector<pii>,greater<pii>>Q;\n\tfor(int i=0;i<=n;i++){\n\t\tdist[i]=inf;\n\t\tcost[i]=inf;\n\t}\n\tdist[start]=0;\n\tcost[start]=0;\n\tQ.push(make_pair(0,start));\n\t//循环开始 \n\twhile(!Q.empty()){\n\t\tint u=Q.top().second;  \n\t\tQ.pop();\n\t\tfor(int v=1;v<=n;v++){\n\t\t\tif(dist[v]>dist[u]+graph[v][u] ||(dist[v]==dist[u]+graph[v][u] && cost[v]>cost[u]+price[v][u]) ){\n\t\t\t\tdist[v]=dist[u]+graph[v][u];\n\t    \t\tcost[v]=cost[u]+price[v][u];\n\t    \t\tQ.push(make_pair(dist[v],v)); //可知道，一次循环可能不止向Q内加入一对数据，但是优先队列总是能够让找到顶部那个距离属性最小的 \n\t\t\t}else if(dist[v]==dist[u]+graph[v][u] && cost[v]>cost[u]+price[v][u]){\n\t\t\t\tcost[v]=cost[u]+price[v][u];\n\t\t\t}\n\t\t} \n\t}\n}\nint main(){\n\tint m,a,b,c,d;\t\n\tint begin , end;\n\twhile(~scanf(\"%d%d\",&n,&m)&& n){\n\t\tfor (int i = 1; i <= n; ++i){\n\t\t\tfor (int j = 1; j <= n; ++j){\n\t\t\t\tgraph[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\tif (graph[a][b] == inf ||   (graph[a][b] != inf && \t(graph[a][b] > c || (graph[a][b] == c && price[a][b] > d)))){\n\t\t\t\tprice[a][b] = d;\n\t\t\t\tprice[b][a] = d;\n\t\t\t\tgraph[a][b] = c;\n\t\t\t\tgraph[b][a] = c;\n\t\t\t}\n\t\t}\t\n\t\tscanf(\"%d%d\",&begin,&end);\n\t\tDijkstra(begin);\n\t\tprintf(\"%d %d\\n\", dist[end], cost[end]);\n\t}\n\treturn 0;\n}\n```\n\n","tags":["ACM"]},{"title":"三类背包","url":"/2018/11/09/三类背包/","content":"\n---\n\n<!--more-->\n\n## 01背包\n\n```c++\n// 01 背包，很直接很简单\n//背包容量一定，一堆物品的 重量--价值 也知道了， 一个一个看，我是选还是不选呢？\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\t int m,n;//先读入背包最大容量和物品的个数\n\t cin>>m>>n;\n\t int dp[m+1];\n\t \n\t int wet[n+5];//记录物品重量\n\t int val[n+5];//记录物品价值\n\t for(int i=1;i<=n;i++){\n\t \tcin>>wet[i]>>val[i];\n\t } \n\t \n\t memset(dp,0,sizeof(dp));\n\t \n\t for(int i=1;i<=n;i++)\n\t     for(int j=m;j>=0;j--)  //每次 考虑一个商品的时候，咱都要从 m 再开始 \n\t         if(j>=wet[i])\n\t         dp[j]=max(dp[j-wet[i]]+val[i],dp[j]);\n\t         \n\t         \n    cout<<dp[m];     \n} \n```\n\n## 完全背包\n\n```c++\n//完全背包，你去看看01背包，完全背包和那个的唯一差别是 这里的物品是无限的 \n// 这个完全背包 写起来 还是比 01背包简单点 \n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\t int m,n;//先读入背包最大容量和物品的个数\n\t cin>>m>>n;\n\t int dp[m+1];\n\t \n\t int wet[n+5];//记录物品重量\n\t int val[n+5];//记录物品价值\n\t for(int i=1;i<=n;i++){\n\t \tcin>>wet[i]>>val[i];\n\t } \n\t \n\t memset(dp,0,sizeof(dp));\n\n     for(int i=1;i<=n;i++)\n\t     for(int j=wet[i];j<=m;j++)\n\t\t      dp[j]=max( dp[j-wet[i]]+val[i] , dp[j]);\n\tcout<<dp[m]<<endl; \n}\n```\n\n## 多重背包\n\n```c++\n//多重背包 是啥呢， 就是 其他和01 背包一样，就是这物品数量，既不是一个，也不是无限个，是 不定数目\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n\t int m,n;//先读入背包最大容量和物品的个数\n\t cin>>m>>n;\n\t int dp[m+1];\n\t \n\t int wet[n+5];//记录物品重量\n\t int val[n+5];//记录物品价值\n\t int amt[n+5];//记录 每个物品的数量 \n\t for(int i=1;i<=n;i++){\n\t \tcin>>wet[i]>>val[i]>>amt[i];\n\t } \n\t \n\t memset(dp,0,sizeof(dp));\n\t\n\t for(int i=1;i<=n;i++)\n\t     for(int j=0;j<amt[i];j++) //商品数目\n\t         for(int k=m;k>=wet[i];k--)\n\t            dp[k]=max(dp[k-wet[i]]+val[i],dp[k]);\n    \n    \n    \n\tcout<<dp[m];     \n} \n```\n\n","tags":["算法"]},{"title":"恶心","url":"/2018/11/09/恶心/","content":"\n---\n\n\n\n<!--more-->\n\n这清楚地被人看到，A先生独自一个人在屋顶打转，他低着头看着自己的脚尖，他越走越快，地上被他用皮鞋明显地划出了一个圆，A先生甚至觉得，自己也跟不上自己。\n\nA先生是一个陀螺。\n\n我想解救A先生出来，我想让这个不停打转的A先生，停下来。\n\n您可能会问，问我为什么，劝我不要这样做。\n\n您对我讲，这个世界上有一条道理，就是千万不要碰一个，原地打转的陀螺。\n\n但我要这样做，因为，我也是个陀螺。\n\n只有我旋转到一个特定的角度里，我才用眼睛看见，和我一样打转的A先生。\n\n\"你好啊! \"我边旋转边向A先生打招呼。\n\n但这位A先生，似乎不情愿我这样做，我见他低着头，脚步规整。\n\n于是我加速旋转，这下子啊，A先生的轮廓，就完完整整地呈现在了，我的眼珠里面。\n\n\"你为什么旋转呢?\"我问A先生。\n\n\n\n\"为什么?\"他轻声说。\n\n\"什么为什么?\" 我回答他。\n\n“为什么你看得见我?”  他的脸扭到了一团  \"我却看不见自己?\"\n\n我笑着对他说，\"哈哈，A先生，我们怎么可能看的到自己呢?\" \n\n”你” 他接着说道 “也是我的剥夺者之一，你属于，地狱，对，你是我的地狱，你看到我，但我却看不到我自己，我将存在于被存在之中，你无疑，是我的恶魔，我并不能时时刻刻都认识到这处，我已经受损。“ \n\n听到这里，我立即恶心起来。\n\n”先生！我怎么可能属于，地狱，这种词汇？ 您如果想看清自己，您想这样做的话，您完全不必旋转，您必须停下来!\"\n\n\n\n\" 那你呢? \" 他问我。\n\n\n\nA先生是个陀螺，旋转的陀螺。\n\n \n\n\n\n","tags":["话"]},{"title":"基础:从数独看Dfs","url":"/2018/11/08/基础从数独看Dfs/","content":"\n----\n\n<!--more-->\n\n题目大意是:\n玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个同色九宫内的数字均含1-9，不重复，输入如\n\n`005300000\n800000020\n070010500\n400005300\n010070006\n003200080\n060500009\n004000030\n000009700`\n\n要求输出\n\n`145327698\n839654127\n672918543\n496185372\n218473956\n753296481\n367542819\n984761235\n521839764`\n\n## 分析：\n\n1： 九宫格的规则我们直到，同行，同列，同宫，必须是不以一样的，所以筛选方向就有三个\n\n```c++\nint is_row_col_exist(int row,int col,int num){ //筛选同行同列，看看有没有一样的，否则返回1成功\n\tfor(int i=1;i<10;i++){\n\t\tif(map[row][i] == num){\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<10;i++){\n\t    if(map[i][col] == num){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint check_part(int row,int col,int num){//筛选同宫，看看传入的 num 在不在(row,col)所处的宫里面，不在的话返回1\n\tint partx = (row-1)/3;\n\tint party = (col-1)/3;\n\tint x= (partx)*3+1;\n\tint y = party*3+1;\n\t\n\tif(\n\t    map[x][y] == num||\n\t    map[x+1][y] == num||\n\t    map[x+2][y] == num||\n\t    map[x][y+1] == num||\n\t    map[x+1][y+1] == num||\n\t    map[x+2][y+1] == num||\n\t    map[x][y+2] == num||\n\t    map[x+1][y+2] == num||\n\t    map[x+2][y+2] == num||\n\t)return 0;\n\treturn 1;\n}\n```\n\n\n\n\n\n好了，基本上，上面就解决了我们过滤的问题，接下里是`Dfs`\n\n```c++\nvoid Dfs(int x.int y){\n\tif(row > 9){\n\t\tfor(int i=1;i<10;i++){\n\t\t\tfor(int j =1;j<10;j++){\n\t\t\t\tprintf(\"%d\",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}return ;\n\t}\n\tif(map[x][y] == 0){\n\t\tfor(int i=1;i<10;i++){\n\t\t\tif(is_row_col_exist(x,y,i) &&  check_part(x,y,i) ) {\n\t\t\t\tmap[x][y]=i;\n\t\t\t\tDfs(x+(y+1)/10,(y+1)%10);\n\t\t\t}   \n\t\t}\n\t\tmap[i][j] = 0;\t\n\t}else{\n\t\tDfs(x+(y+1)/10,(y+1)%10);\n\t}\n\t\n}\n```\n\n*第一问题·*： **搜索搜索，从哪里开始呢？**\n\n```\n是的，我们首先要找到一个入口，这个入口一般是什么？\n是矩阵的最边缘，是一个可以有能力通过循环跑遍所有情况的位置。\n```\n\n*第二问题*： **回溯的必要性**\n\n```\n倘若没有回溯条件，必定爆栈\n而往往回溯条件不是那么的容易找到(至少对于我来讲是这样的)\n这个数独题存在：    Dfs(x+(y+1)/10,(y+1)%10)\n\n一号位参数 和 二号位参数 是存在递增的，但我们的9X9,所以条件就是： 行数不能超过了最大(我觉得不容易找到)\n```\n\n*第三问题* ： **dfs的基本形状**\n\n```\ndfs{\n    \n    /*跳出条件{\n        成功了\n        return;\n    }*/\n    \n    终止条件{\n       不用再进行了，已经失败了\n       return\n     }\n     \n   循环{ \n    是符合条件的{\n        信息改变\n        dfs(下一位) //向深处进行\n    }\n  }   \n   信息恢复   //为什么呢？？ 因为这里的信息受到改变，且肯定是不满足条件的，那么为了使接下来的程序顺利执行，必须信息恢复，否则这个信息的影响会贯穿下去。这会让深度搜索进行不下去。\n}\n```\n\n完全代码\n\n```\n#include <iostream>\n#include <string>\nusing namespace std;\nint a[10][10];//存储数字\nint is_row_col_repeat(int row,int col,int num){//判断行列是否重复\n    //判断行是否重复\n    for (int i=1;i<=9;i++) {\n        if (a[row][i]==num) {\n            return 0;//行重复，返回0\n        }\n    }\n    //判断列是否重复\n    for (int i=1;i<=9;i++) {\n        if (a[i][col]==num) {\n            return 0;//列重复，返回0\n        }\n    }\n    return 1;//行列不重复，返回1\n}\nint check_row_range(int row){//判断行的范围\n    if (row>=1 && row<=3) {\n        return 1;\n    }else if(row>=4&&row<=6){\n        return 4;\n    }else {\n        return 7;\n    }\n}\nint check_col_range(int col){//判断列的范围\n    if(col>=1&&col<=3){\n        return 1;\n    }else if (col>=4&&col<=6) {\n        return 4;\n    }else {\n        return 7;\n    }\n}\nint is_block_repeat(int row,int col,int num){//判断同色九宫格是否重复\n    int x,y;\n    x=check_row_range(row);\n    y=check_col_range(col);\n    for (int i=x;i<=x+2;i++) {\n        for (int j=y;j<=y+2;j++) {\n            if (a[i][j]==num) {\n                return 0;//重复，返回0\n            }\n        }\n    }\n    return 1;//不重复，返回1\n}\n\nvoid dfs(int row,int col){\n    if (row>9) {//如果行超出9行，直接输出\n        for (int i=1;i<=9;i++) {\n            for (int j=1;j<=9;j++) {\n                printf(\"%d\",a[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        exit(0);\n    }\n\n    if (a[row][col]==0) {//如果没有填数字\n        for (int i=1;i<=9;i++) {\n            if (is_row_col_repeat(row, col, i) && is_block_repeat(row, col, i)) {//如果行列九宫格不重复\n                a[row][col]=i;//填充数字\n                dfs(row+(col+1)/10, (col+1)%10);//继续搜索\n            }\n        }\n        a[row][col]=0;//重新置为0\n    }else{//如果已经填了，继续搜索\n        dfs(row+(col+1)/10, (col+1)%10);\n    }\n}\nint main(int argc, char *argv[]) {\n    string s;\n    for(int i=1;i<=9;i++){\n        cin >> s;//输入字符串\n        for(int j=1;j<=9;j++){\n            char ss=s.at(j-1);//取s的第j-1的字符\n            a[i][j]=ss-'0';//将ss转化为整数\n        }\n    }\n    dfs(1,1);\n    return 0;\n}\n```\n\n\n\n","tags":["算法"]},{"title":"Berlekamp-Massey算法","url":"/2018/11/08/Berlekamp-Massey算法/","content":"\n---\n\n<!--more-->\n\n坑在这","tags":["算法"]},{"title":"快速幂&矩阵快速幂","url":"/2018/11/07/快速幂&矩阵快速幂/","content":"\n----\n\n<!--more-->\n\n## 快速幂\n\n计算关于: p^n 问题，带入实例最易理解\n\n```c++\nlli QuickPow(int x,int n ){  //x^\n    lli snowball = x;\n\tlli ans = 1;\n\twhile(n){\n\t\tif(a&1){\n\t\t\tans *=snowball;\n\t\t}\n\t\tsnowball*=snowball;\n\t\tn>>=1;\n\t}\n    return ans;\n}\n```\n\n## 矩阵快速幂\n\n矩阵快速幂是快速幂在矩阵连乘上的应用，快速幂是种思想，而矩阵快速幂指某算法在它内部可能有一部分是矩阵连乘，然后使用的了快速幂的模板，以此类推，我们可以有很多种的快速幂了。\n\n也就是上面的代码。\n\n针对这个问题\n\n[Poj-------Fibonacci](http://poj.org/problem?id=3070)\n\n我觉得这个题的精髓不在快速幂，而在从斐波那契数列 到 矩阵连乘的转化。四个字:  **化加为乘** ，使得我们能用快速幂。\n\n图示如下：\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwzy5ggbiqj31hc140jw0.jpg)\n\n存个模板先\n\n```c++\ntypedef struct{\n\tint a[2][2];\n}node;\n\nnode multi(node s, node b){\n    node temp;\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\ttemp.a[i][j] = 0;\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\ttemp.a[i][j]=(temp.a[i][j]+(s.a[i][k]*b.a[k][j]))%10000;\n\t\t\t}\n\t\t}\n\t}\n\treturn temp;\n}\n\nint martix_quick(node snowball,int n){\n  \n    snowball.a[0][0] = 1;\n    snowball.a[0][1] = 1;\n    snowball.a[1][0] = 1;\n    snowball.a[1][1] = 0;\n \n    node b;\n    \n    for(int i=0;i<2;i++)\n    {\n        for(int j=0;j<2;j++)\n        {\n            b.a[i][j]=(i==j);\n        }\n    }\n\t\n\twhile(n){\n\t\tif(n&1){\n\t\t\tb=multi(b,snowball);\n\t\t}\n\t\tn>>=1;\n\t\tsnowball=multi(snowball,snowball);\n\t}\n\treturn b.a[0][1];\n}\n```\n\n\n\n[解释好文](https://www.cnblogs.com/cmmdc/p/6936196.html)\n\n[poj我的码](https://paste.ubuntu.com/p/Fqkr3xV5NS/)","tags":["算法"]},{"title":"Kmp字符串匹配算法","url":"/2018/11/05/Kmp/","content":"无参考意义\n\n<!--more-->\n\n\n\nS: 等待被匹配的字符串     `abcabcabccabcd`\n\nC: 匹配字符串                    `abcc`\n\n---\n\n## 第一部分\n\nnext 数组下标从`0`开始，`next[0] = -1`,\n\n下标  1，2，3，4 · · · 代表:  `C这个字符串，长度到1,2,3,4··· 位置时候，我们究竟能够能找到多长的对称前后缀`\n\n```\n比如对于这个next:\nnext[0] = -1\nnext[1] = 0\nnext[2] = 0\nnext[3] = 0 \nnext[4] = 1\n```\n\n代码实现：(不理解的时候，用笔写出来)\n\n```c++\nvoid get_next(){\n\tint k=-1;\n\tint j=0;\n\tnext[0] = -1;      \n\twhile(j<c_len){                        #j代表着我们已经完成了几个\n\t\tif( k==-1 || next[k]==next[j]){   \n\t\t\tk+=1;\n\t\t\tj+=1;\n\t\t\tnext[j]=k;\n\t\t}else\n\t\tk=next[k];    \n\t}\n\treturn ;\n}\n```\n\n## 第二部分\n\n---\n\n```\nint Kmp(char *c,char *s){\n\tint i=0;\n\tint j=0;\n\tint sum=0;\n\tget_next();\n\twhile(i < s_len){  #大的串，不要越界了\n\t\n\t\n\t    if(j==-1 || c[j]==s[i]){  #核心\n\t    \ti++;\n\t    \tj++;\n\t\t}else{\n\t\t\tj=next[j];\n\t\t}\n\t\t\n\t\t\n\t\tif(j==c_len){  #匹配完成了啊，就记录一个，j重新开始\n\t\t\tsum++;\n\t\t    j=0;\n\t\t}\n\t}\n\treturn sum;\n}\n\n```\n\n实例:\n\n```c++\n#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#include<string.h>\n#define  maxn 10000\n\nchar  c[maxn];\nchar  s[maxn];\nint   next[maxn];\nint  c_len,s_len;\n\nvoid get_next(){\n\tint k=-1;\n\tint j=0;\n\tnext[0] = -1;\n\twhile(j<c_len){\n\t\tif( k==-1 || next[k]==next[j]){\n\t\t\tk+=1;\n\t\t\tj+=1;\n\t\t\tnext[j]=k;\n\t\t}else\n\t\tk=next[k];\n\t}\n\treturn ;\n}\nint Kmp(char *c,char *s){\n\tint i=0;\n\tint j=0;\n\tint sum=0;\n\tget_next();\n\twhile(i < s_len){\n\t    if(j==-1 || c[j]==s[i]){\n\t    \ti++;\n\t    \tj++;\n\t\t}else{\n\t\t\tj=next[j];\n\t\t}\n\t\tif(j==c_len){\n\t\t\tsum++;\n\t\t    j=0;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tprintf(\"输入待比较字符串:\\n\");\n\tscanf(\"%s\",s);\n\tprintf(\"输入比较字符串:\\n\");\n\tscanf(\"%s\",c);\n\tc_len = strlen(c);//sizeof(c)/sizeof(char);\n\ts_len = strlen(s);//sizeof(s)/sizeof(char);\n    printf(\"%d\",Kmp(c,s));\n}\n```\n\n","tags":["算法"]},{"title":"红龙","url":"/2018/11/05/红龙/","content":"\n---\n\n<!--more-->\n\n每当我认为，自己清醒的认识到，它的起因，经过，和结果时，我却无法集中注意力，我无权，站在这样一个高地。\n\n我审视着它，我看到它吟唱出刺耳的密密麻麻的语句，我感觉得到它们融化，汇合，变为正常，变为我身边的椅子，水杯，台灯，我眼前的手掌的毛孔。\n\n亲爱的，我不得不这样讲，我已由它组成，我不知该怎样做，因为，我已由它组成。\n\n它是红龙，善良而邪恶的无形体现，黑色和白色融合，于我体内而逃于我身，赐予我悲伤和快乐的一切情绪，施加于我痛苦和狂热的次次混乱。\n\n我望着红龙。\n\n\n\n请你告诉我，为什么，我目光下的极限，仅仅是一个可笑无比的紫色的巨大矛盾体。\n\n红龙，你是诱因，你早已彻彻底底的，屈服于这片土地和星辰，在这使人厌恶的距离里，无休止地接受我的祈祷。\n\n\n\n它将会绽放出鲜艳的赤红色的花，它紧闭的嘴中必将发出人类一样的叫声，我已感受的到，红龙之下一切的复苏，\n\n切断一切灌输后的大地，将会彻底区分于你的肌肤。\n\n\n\n我必定要杀死它。\n\n红龙。","tags":["话"]},{"title":"有限状态自动机","url":"/2018/11/04/有限状态自动机/","content":"\n总结\n\n<!--more-->\n\n举例子如图:\n\n\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fww66hr1b9j30vz0mytbc.jpg)\n\n如图 `(q0,a)->q1,(q0,b)->q0` 这就叫做状态转移函数，咋解释呢？ \n\n```\n黄色圆形代表一个一个状态，内部数字就是状态对应的编号\nq0 接受 a 到达 q1 \nq0 接受 b 到达 q0\n. . .\n```\n\n然后就像你看到的，把这些状态(`小括号包括住的`)积攒在一起，就是我们的图1的 `S`也叫`状态集`\n\n这些  `从某个状态到达另外一个状态` 的过程，本身可以称作一个函数，这些函数的集合叫做，转移函数集合。\n\n\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fww682bj7lj30w00ka40t.jpg)\n\n`有限状态自动机： `\n\n1. 非确定有限状态自动机(NFA)\n2. 确定的有限状态自动机(DFA)\n\n\n\n我们第一个图就是个确定的，来看看一个不确定的:\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fww6kumrtij30u00n5dhr.jpg)\n\n这个为什么叫不确定的状态自动机？  你看看， 加入我们给 `q0 传递 a`  ,你能知道 q0到q0，还是q0到q1？？ 你是不确定的，所以含有这种构造的自动机就叫`NFA`\n\n## 实例\n\n问？在NFA中，我们在初始状态为 `q0` 时，传入 字符串s=`\"a\"`,请问对于NFA，它可以接受吗？\n\n答：可以，尽管q0 有可能接受 `a`后还是状态本身，但只要有一条路可转移走，NFA在经过`遍历` 后，就可以找到了！\n\n## 具体实现\n\n我们该怎样把这么一个抽象的自动机通过代码实现呢？\n\n我们其中一个办法就是，图的邻接矩阵实现。\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fww6umswk8j30sq0nnwg3.jpg)\n\n解释：0接受a变为1；0接受b变成0 以此类推","tags":["complier"]},{"title":"从微博spider详解Scrapy","url":"/2018/11/03/从微博spider详解Scrapy/","content":"\n本文旨在彻底剖析Scrapy爬虫框架\n\n<!--more-->\n\n## 目的\n\n针对: `https://m.weibo.cn` 爬取新浪微博用户的公开基本信息，如用户昵称、头像、用户的关注、粉丝列表以 及发布的微博等，这些信息抓取之后保存至 MongoDB。\n\n\n\n## 前提\n\n情确保前文所讲的代理池、 Cookies 池已经实现并可以正常运行，安装 Scrapy、 PyMongo 库，如 没有安装可以参考前文内容\n\n## 开始\n\n针对请求解析不再过多阐述， \n\n从XHR分析可知，请求类型为Get ,因此，模仿创造请求。\n\n`https://m.weibo.cn/api/container/getlndex?contaiaerid= 231 051二followers-_1916655407 &luicode= I 00000 l l&lfid= I 005051916655407 &featurecode=20000320&type =uid&value= 1916655407 &page=2`\n\n其中最主要的参数就是 containerid 和 page。 有了这两个参数，我们同样可以获取请求结果。 我 们可以将接口精简为  https://m.weibo.cn/api/container/getIndex?containerid=231051-_followers-_1916655407&page=2\n\n\n\n","tags":["爬虫"]},{"title":"C++ template —— 模板基础（一）","url":"/2018/11/01/C++-template-——-模板基础（一）/","content":"\nC++的魅力，实在使人难以忘却。\n\n<!--more-->\n\n[拜读](https://www.cnblogs.com/yyxt/category/772515.html)\n\n本文转载于: [博客园_小天](https://www.cnblogs.com/yyxt/)\n\n","tags":["C++"]},{"title":"完美哈希","url":"/2018/10/31/Scrapy框架通用爬虫/","content":"\n通过构造完美哈希，可以在O(1)时间内实现关键字的查询。\n\n 关键字表算法: 通过构造完美哈希，可以在O(1)时间内实现关键字的查询.\n\n<!--more--->\n\n[哈希综述](https://www.cnblogs.com/gaochundong/p/hashtable_and_perfect_hashing.html) \n\n[gperf算法](https://www.ibm.com/developerworks/cn/linux/l-gperf.html)\n\nPHF(*Perfect Hash Function*)和MPHF(*Minimal Perfect Hash Function*)生成算法：\n\n  [A Practical Minimal Perfect Hashing Method](http://homepages.dcc.ufmg.br/~nivio/papers/wea05.pdf)\n\n  [An Approach for Minimal Perfect Hash Functions for Very Large Databases](http://homepages.dcc.ufmg.br/~nivio/papers/tr06.pdf)\n\n  [A New algorithm for constructing minimal perfect hash functions](http://homepages.dcc.ufmg.br/~nivio/papers/tr004_04.ps)\n\n  [A optimal algorithm to generating minimal perfect hash function](http://citeseer.ist.psu.edu/czech92optimal.html)","tags":["complier"]},{"title":"Scrapy对接Splash","url":"/2018/10/29/Scrapy对接Splash/","content":"\n抓取淘宝商品是一种抓取JavaScript渲染页面的方式，除了使用Selenium还有`splash`同样可以达到同样的功能\n\n<!--more-->\n\n老样子，新建一个`项目+爬虫`\n\n```\nscrapy startproject scrapysplashtes\n```\n\n```python\nscrapy genspider taobao www.taobao.com\n```\n\n制造者已经为scrapy制定了完备的splash接口，我们只需:\n\n##  在settings中配置关于splash的相关设置\n\n-->修改settings.py，首先将SPLASH_URL配置一下，在这里我们的Splash是在本地运行的，所以可以直接配置本地的地址\n\n```python\nSPLASH_URL = 'http://localhost:8050'\n```\n\n--> 接下来我们还需要配置几个Middleware\n\n```python\nDOWNLOADER_MIDDLEWARES = {\n    'scrapy_splash.SplashCookiesMiddleware': 723,\n    'scrapy_splash.SplashMiddleware': 725,\n    'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware': 810,\n}\nSPIDER_MIDDLEWARES = {\n    'scrapy_splash.SplashDeduplicateArgsMiddleware': 100,\n}\n```\n\n👆配置了三个Downloader Middleware和一个Spider Middleware，这是ScrapySplash的核心部分，配置了它们我们就可以对接Splash进行页面抓取，在这里我们不再需要像对接Selenium那样实现一个Downloader Middleware，ScrapySplash库都为我们准备好了，直接配置即可.\n\n\n\n着还需要配置一个去重的类DUPEFILTER_CLASS\n\n```python\nDUPEFILTER_CLASS = 'scrapy_splash.SplashAwareDupeFilter'\n```\n\n最后还需要配置一个Cache存储HTTPCACHE_STORAGE\n\n```python\nHTTPCACHE_STORAGE = 'scrapy_splash.SplashAwareFSCacheStorage'\n```\n\n*完成！* \n\n___________\n\n本节我们要做的抓取是淘宝商品信息，涉及到页面加载等待、模拟点击翻页等操作，所以这里就需要Lua脚本来实现了，所以我们在这里可以首先定义一个Lua脚本，来实现页面加载、模拟点击翻页的功能[关于Lua](https://www.runoob.com/lua/lua-tutorial.html)\n\n```python\nfunction main(splash, args)\n  args = {\n    url=\"https://s.taobao.com/search?q=iPad\",\n    wait=5,\n    page=5\n  }\n  splash.images_enabled = false\n  assert(splash:go(args.url))\n  assert(splash:wait(args.wait))\n  js = string.format(\"document.querySelector('#mainsrp-pager div.form > input').value=%d;document.querySelector('#mainsrp-pager div.form > span.btn.J_Submit').click()\", args.page)\n  splash:evaljs(js)\n  assert(splash:wait(args.wait))\n  return splash:html()\nend\n```\n\nlua是一种脚本语言，我们写出一段`lua脚本`之后，对接到SplashRequest中，就可使用\n\n最终taobao.py结果如下:\n\n```python\nfrom scrapy import Spider\nfrom urllib.parse import quote\nfrom scrapysplashtest.items import ProductItem\nfrom scrapy_splash import SplashRequest\n\nscript = \"\"\" #lua脚本\nfunction main(splash, args)\n  splash.images_enabled = false\n  assert(splash:go(args.url))\n  assert(splash:wait(args.wait))\n  js = string.format(\"document.querySelector('#mainsrp-pager div.form > input').value=%d;document.querySelector('#mainsrp-pager div.form > span.btn.J_Submit').click()\", args.page)\n  splash:evaljs(js)\n  assert(splash:wait(args.wait))\n  return splash:html()\nend\n\"\"\"\n\nclass TaobaoSpider(Spider):\n    name = 'taobao'\n    allowed_domains = ['www.taobao.com']\n    base_url = 'https://s.taobao.com/search?q='\n    \n    def process_request(self):\n        for keyword in self.settings.get('KEYWORD'):\n            for page in range(1,self.settings.get('MAX_PAGE')+1):\n                url = self.base_url + quote(keyword)\n                yield SelfshResponse(url,callback = self.parse,endpoint='execute',args={'lua_source':script,'page':page,'wait':7})\n```\n\n`把Lua脚本定义成长字符串`，通过`SplashRequest 的 args`来传递参数，另外args参数里还有一个lua_source字段用于指定Lua脚本内容，这样我们就成功构造了一个SplashRequest，对接Splash的工作就完成了\n\n\n\n接下来的工作就很正常了\n\nsettings中设置\n\n```python\nSPLASH_URL = 'http://192.168.99.100:8050' #而非http://localhost:8050\n\nDOWNLOADER_MIDDLEWARES = {\n    'scrapy_splash.SplashCookiesMiddleware': 723,\n    'scrapy_splash.SplashMiddleware': 725,\n    'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware': 810,\n}\nSPIDER_MIDDLEWARES = {\n    'scrapy_splash.SplashDeduplicateArgsMiddleware': 100,\n}\n#去重的类DUPEFILTER_CLASS\nDUPEFILTER_CLASS = 'scrapy_splash.SplashAwareDupeFilter'\n#一个Cache存储HTTPCACHE_STORAGE\nHTTPCACHE_STORAGE = 'scrapy_splash.SplashAwareFSCacheStorage'\n```\n\n*此处必须解释一下，曾在这里卡到了第一句话上，崔庆才老师设置的是后者，这和docker开的端口有关*\n\n首先打开`virtualbox`，开启`default`服务，同时打开`docker quickstart terminal`\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwr5oncmf5j30lv0a3mx9.jpg)\n\n/*如果docker出现什么报错，就先解决那个问题,刚接触docker，感觉这个东西坑很深*/ ,\n/*过程中请保持virtualbox的default打开*/\n 我们清楚的看到`docker被配置为使用IP 192.168.99.100的默认机器`\n\n所以，使用docker必须splash_url改为`http://192.168.99.100:8050`\n\n\n\n运行\n\n```\nscrapy crawl taobao\n```\n\n爬虫的速度将是惊人的。","tags":["爬虫"]},{"title":"Scrapy框架(二)","url":"/2018/10/28/Scrapy框架(二)/","content":"\n从实例中看scrapy框架中各部分的功能\n\n![](https://wx1.sinaimg.cn/mw690/6c3e6b13gy1fwjoq4i6rcj20zk0wk4qp.jpg)\n\n<!--more-->\n\n取的目标网站为：https://image.so.com\n\n打开浏览器开发者工具，过滤器切换到XHR选项,下拉页面，可以看到下面就会呈现许多Ajax请求\n\n![](https://ask.qcloudimg.com/http-save/developer-news/q8remsppeb.jpeg)\n\n![](https://ask.qcloudimg.com/http-save/developer-news/7xvqjdt74l.jpeg)\n\n返回格式是JSON。其中字段就是一张张图片的详情信息，包含了30张图片的ID、名称、链接、缩略图等信息。另外观察Ajax请求的参数信息，有一个参数一直在变化，这个参数很明显就是偏移量。当为30时，返回的是前30张图片，sn为60时，返回的就是第31~60张图片。\n\n实际上，我们向浏览器发送ajax请求，我们从网址上，即被url编码的params列表，比如：\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwo4qvh794j311b0bu75u.jpg)\n\n我们看到了:\n\n1. ch\n2. sn\n3. listtype\n4. temp\n\n所以所谓的参数列表\n\n```\nparams{\n    xxx\n    xxx\n    xxx\n}\n```\n\n只用含有这几个参数就可以了。\n\n____\n\n分析完毕后，开始新建项目.\n\n```\nscrapy startproject images360\n```\n\ncd 到这个项目的 spiders项目下，创建一个爬虫名为`images360`\n\n```\nscrapy genspider images360  images.so.com\n```\n\n**有了爬虫，接下来应该做什么？**🧐\n\n## 第一 ##\n\n肯定是要对spiders处理，我们进入spiders文件夹里面的`images.py`里看，爬虫有了，方法要我们创建。\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwo522pfeyj30ld0ic0ti.jpg)\n\n这里的爬虫有三个部分:\n\n*1* :  `name`是爬虫名，`allowed_domain `是访问的域名，`start_urls`的含义是过滤爬取的域名，在插件OffsiteMiddleware启用的情况下（默认是启用的），不在此允许范围内的域名就会被过滤，而不会进行爬取,\n\n请注意,以上三个部分，都是在我们第二个命令执行时，S框架自动生成的，我们不用动.\n\n*2*: `start_requests`就算是我们熟悉的通过循环向浏览器发送ajax请求，`parse`是对返回的response进行解析，我们知道，基本的爬虫实现都是在这里做的。\n\n\n\n我们重点关注其他部分，也就是框架的其他环节\n\n```\nitem\nmiddleware\nsettings\npiplines\n```\n\n`item`:打个比方，你想要你爬到的东西的什么部分？你希望他们以什么样子交给你？\n\n​               我想要网站图片的id,链接地址，主题，缩略图,我想要它们以一个字典的形式呈交给我\n\n​              那么，item.py就是干这个的.​           \n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwo5bmi8y8j30h80ai3ym.jpg)\n\n`middleware`:中间件，作用是修改代理ip啦，访问浏览器的user_agent啦，[了解一下](https://blog.csdn.net/yancey_blog/article/details/53896092) ,此例不用middleware     \n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwo6sjw5saj30mq0p80ua.jpg)","tags":["爬虫"]},{"title":"Ajax和XHR","url":"/2018/10/28/Ajax和XHR/","content":"\n  ajax是asynchronous javascript and XML的简写\n\n<!--more--->\n\n[拜读](https://www.cnblogs.com/xiaohuochai/p/6036475.html)\n\n<br><br><br><br>","tags":["前端基础"]},{"title":"Scrapy框架解析","url":"/2018/10/26/Scrapy/","content":"\nScrapy是一个非常优秀的爬虫框架\n\n<!--more-->\n\n###  什么是Scrapy？ \n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwml6x6211j30jg0dqdi2.jpg)\n\n`Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中`\n\n### 1 . [先安装](https://www.cnblogs.com/lfoder/p/6565088.html)\n### 2. 第一个项\n`scrapy startproject tutorial` \n直接cmd执行，然后在   c/user/xxx   路径下，出现了一个tutorial 文件夹\n\n\n\n\n\n### Downloader Middleware 🔍\n\nMiddleware 是整个scrapy框架中负责网页下载环节的工作，比如说 我们有一个新的项目，并有个该项目下的spider\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass HttpbinSpider(scrapy.Spider):\n    name = 'httpbin'\n    allowed_domains = ['httpbin.org']\n    start_urls = ['http://httpbin.org/get']\n\n    def parse(self, response):\n        self.logger.debug(response.text) #打印响应\n        self.logger.debug('Status Code: ' + str(response.status))\n```\n\n执行spider\n\n```c&#39;m&#39;d\nscrapy crawl httpbin\n```\n\n发现获取到的内容中含有:\n\n```html\n2018-10-27 08:57:09 [scrapy.statscollectors] INFO: Dumping Scrapy stats:\n{'downloader/request_bytes': 439,\n 'downloader/request_count': 2,\n 'downloader/request_method_count/GET': 2,\n 'downloader/response_bytes': 768,\n 'downloader/response_count': 2,\n 'downloader/response_status_count/200': 2,\n 'finish_reason': 'finished',\n 'finish_time': datetime.datetime(2018, 10, 27, 0, 57, 9, 949044),\n 'log_count/DEBUG': 5,\n 'log_count/INFO': 7,\n 'response_received_count': 2,\n 'scheduler/dequeued': 1,\n 'scheduler/dequeued/memory': 1,\n 'scheduler/enqueued': 1,\n 'scheduler/enqueued/memory': 1,\n 'start_time': datetime.datetime(2018, 10, 27, 0, 57, 8, 773548)}\n```\n\n其中的`headers`中的`User_Agent` 是`DownloaderMiddleware`并利用 process_request（）方法设置的 User_Agent\n\n我们改动一下 `midddlerware.py`，添加一个RandomUserAgentMiddleware类 ，如下\n\n```python\nimport random\n\nclass RandomUserAgentMiddleware(self):\n    def __init__():\n        self.user_agent=[\n        1.代理\n        2.代理\n        3.代理\n        ]\n    def process_request(self,request,spider):\n        request.headers['User_Agent'] = random.choice(self.user_agent)\n```\n\n并且必须在settings.py中取消注释:  `DOWNLOADER_MIDDLEWARES `并设置成如下内容:\n\n```\nDOWNLOADER_USERAGENT{\n    'scrapydownloadermiddtest.middlewares.RandomUserAgentMiddleware': 543,\n}\n```\n\n接下来我们重新运行 Spider，就可以看到 User-Agent 被成功修改为列表中所定义的随机的一个 User-Agent 了\n\n\n\n\n\n Downloader Middleware 还有` process_response()`方法。 Downloader对 Request 执行下载之 后会得到 Response，随后 Scrapy 引擎会将 Response 发送回 Spider进行处理。 但是在 Response 被发送 给 Spider 之前，我们同样可以使用` process_response()`方法对 Response 进行处理\n\n```\ndef process_response(self, request, response, spider):\n    response.status = 201 \n    return response` \n```\n\n我们将 response 变量的 status 属性修改为 201 ，随后将 response 返回，这个被修改后的 Response 就会被发送到 Spider。\n我们再在 Spider里面输出修改后的状态码，在 parse() 方法中添加如下的输出语句：\n\n```\nself.logger.debug（'StatusCode:' + str(response.status)) \n```\n\n重新运行之后，控制台输出了如下内容：\n`[httpbin] DEBUG: Status Code: 201 `\n\n Response 的状态码成功修改了。\n因此要想对 Response 进行后处理，就可以借助于` process_response()`方法\n\n\n\n###  SpiderMiddleware 用法🏳‍🌈\n\nSpider中间件是在引擎及Spider之间的特定钩子(specific hook)，处理spider的输入(response)和输出(items及requests)。 其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。更多内容请看 Spider中间件(Middleware) \n一句话总结就是：`处理解析部`\n\n### Item PipeLine 用法🐱‍👓\n\n当spider爬取到item后，它被发送到项目管道（Item Pipeline），通过几个组件按顺序进行处理。每一个Item Pipeline是一个实现了简单方法的Python类，它接收到一个item并对其执行一个操作，也要决定该item是否应该继续通过管道，或者被丢弃，不再进行处理。\n\n`简单来说，我们通过爬虫爬取的项目，先交给项目管道，项目管道把数据处理处理(删除一些啦，存到mongodb啦)产生新的item`\n\n**Item Pipeline典型的用途是：**\n1.清理HTML数据\n2.验证爬取的数据(检查items是否包含某些字段)\n3.检查副本(并删除它们)\n4.将item数据存储在数据库中\n\n`每个Item Pipeline都是一个Python类`，它必须实现以下方法:\n\n**process_item(self, item, spider)**\n\n这个方法可以被每个Item Pipeline调用，process_item()必须是:返回一个字典类型数据、返回一个条目(或任何子类)对象，返回一个 Twisted Deferred 或者DropItem异常，丢弃的item不再由进一步的Item Pipeline处理。\n参数含义：\nitem： Item对象或字典，爬取的item\nspider：spider对象，爬取了这个item的spider\n此外，他们还可以实现以下方法:\n\n**open_spider(self, spider)** ->当spider打开时，函数就会被调用，spider参数含义：被打开的spider\n**close_spider(self, spider)**  ->当spider关闭是，函数会被调用\n**from_crawler(cls, crawler)**  -> 如果存在，这个类方法被调用来从一个Crawler创建一个spider实例。它必须返回管道的一个新实例，Crawler对象提供对所有的scrapy核心组件的访问，比如设置和信号;这是管道访问它们并将其功能连接到scrapy的一种方式。\n\n\n\n\n\n\n\n\n\n\n\n----\n\n参考链接:\n\n​              [Scrapy进阶,middleware的使用](https://blog.csdn.net/xnby/article/details/52297047)\n\n​              [运维学Python之爬虫高级篇](http://blog.51cto.com/linuxliu/2068601?wx)\n\n​              ","tags":["爬虫"]},{"title":"不该死的人，还活着","url":"/2018/10/21/nuisance/","content":"我再次体会到将要放弃的感觉，此刻我想的并不是，黑色成为黑色的原因，而是眼前的红色为什么这么刺眼。\n<!--more-->\n\n\n\n\n","tags":["话"]},{"title":"qppium模拟---微信朋友圈","url":"/2018/10/20/wechatspider/","content":"\n初尝Android爬虫\n<!--more-->\n\n## 1. appium介绍 ## \n\n____\n\n[官方文档](https://testerhome.com/wiki/appiumdoccn)\n\n```c\nAppium is an open source test automation framework for use with native and hybrid mobile apps.\n```\n\n如果说我们可以使用Selenium在web端对行为进行模拟，那么Appnium即是我们针对App的操作模拟器。\n\n## 2 . 爬取思路\n___\n\n点击 Start Server按钮即可启动 Appium 的服务，相当于开启了一个 Appium 服务器。 我们可以通过 Appium 内置的驱动或 Python代码向 Appium 的服务器发送一系列操作指令， Appium 就会根据 不同的指令对移动设备进行驱动，完成不同的动作\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwhfvq2ynqj30m50kiwfv.jpg)\n\nAppium 运行之后正在监听 4723 端口 。 我们可以向此端口对应的服务接口发送操作指令，此页面就会显示这个过程的操作日志\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwhfw7fi3fj30m30klgls.jpg)\n\n*开始连接*\n\n\n1.Android 手机通过数据线和运行 Appium 的 PC 相连，同时打开 USB 调试功能\n2.cmd 输入`adb devices`，得到设备名称\n3.配置Capability参数(如下图)，其中：\n​     //  platformName： 它是平台名称，需要区分 Android 或 iOS，此处填写 Android  \n​     //  deviceName： 它是设备名称，此处是手机的具体类型。 \n​     //  appPackage： 它是 App 程序包名。通过cmd命令`adb shell pm list packages`可查\n​     //  appActivity： 它是入口 Activity 名，这里通常需要以．开头。\n4.start Session\n\n​                                                    \n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fwhfwunwn5j31160jignb.jpg)\n\n 到这里，我们可以在appium看到每块元素的id，xpath定位等信息， 同时，  tap(),click(),等动作函数，也给我们随心所欲的模拟提供空间。\n\n就是`定位`+`获取`，并把获取内容存入MongoDB\n\n//定位可通过 ID，或直接 XPATH 定位(事实上，appium很人性化的直接为用户提供了某元素的XPATH查找路径)\n\n//截至10.23 0:17 仍未找到获取文本安卓元素对应的文本的方法。\n\n```python\nimport os \nfrom appium import webdriver\nfrom appium.webdriver.common.touch_action import TouchAction\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom pymongo import MongoClient\nfrom time import sleep\nfrom processor import Processor\nfrom config import *\n\n\nclass Moments():\n    def __init__(self):\n        \"\"\"\n        初始化\n        \"\"\"\n        # 驱动配置\n        self.desired_caps = {\n            'platformName': PLATFORM,\n            'deviceName': DEVICE_NAME,\n            'appPackage': APP_PACKAGE,\n            'appActivity': APP_ACTIVITY\n        }\n        self.driver = webdriver.Remote(DRIVER_SERVER, self.desired_caps)\n        self.wait = WebDriverWait(self.driver, TIMEOUT)\n        self.client = MongoClient(MONGO_URL)\n        self.db = self.client[MONGO_DB]\n        self.collection = self.db[MONGO_COLLECTION]\n        # 处理器\n        self.processor = Processor()\n    \n    def login(self):\n        \"\"\"\n        登录微信\n        :return:\n        \"\"\"\n        # 登录按钮\n        login = self.wait.until(EC.presence_of_element_located((By.ID, 'com.tencent.mm:id/d75')))\n        login.click()\n        # 手机输入\n        phone = self.wait.until(EC.presence_of_element_located((By.ID, 'com.tencent.mm:id/hz')))\n        phone.set_text(USERNAME)\n        # 下一步\n        next = self.wait.until(EC.element_to_be_clickable((By.ID, 'com.tencent.mm:id/alr')))\n        next.click()\n        # 密码\n        password = self.wait.until(\n            EC.presence_of_element_located((By.XPATH, '//*[@resource-id=\"com.tencent.mm:id/hz\"][1]')))\n        password.set_text(PASSWORD)\n        # 提交\n        submit = self.wait.until(EC.element_to_be_clickable((By.ID, 'com.tencent.mm:id/alr')))\n        submit.click()\n        submit = self.wait.until(EC.element_to_be_clickable((By.ID, 'com.tencent.mm:id/an3')))\n        submit.click()\n    \n    def enter(self):\n        \"\"\"\n        进入朋友圈\n        :return:\n        \"\"\"\n        # 选项卡\n        tab = self.wait.until(\n            EC.presence_of_element_located((By.XPATH, '//android.widget.FrameLayout[@content-desc=\"当前所在页面,与wxid_br71rgy4kg5n22的聊天\"]/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.view.ViewGroup/android.widget.FrameLayout[1]/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.RelativeLayout/android.widget.LinearLayout/android.widget.RelativeLayout[3]/android.widget.LinearLayout/android.widget.RelativeLayout/android.widget.ImageView')))\n        tab.click()\n        # 朋友圈\n        moments = self.wait.until(EC.presence_of_element_located((By.ID, 'com.tencent.mm:id/a7f')))\n        moments.click()\n    \n    def crawl(self):\n        \"\"\"\n        爬取\n        :return:\n        \"\"\"\n        while True:\n            # 当前页面显示的所有状态\n            items = self.wait.until(\n                EC.presence_of_all_elements_located(\n                    (By.XPATH,'//android.widget.FrameLayout[@content-desc=\"当前所在页面,朋友圈\"]/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.view.ViewGroup/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.RelativeLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.ListView/android.widget.FrameLayout')))\n            # 上滑\n            self.driver.swipe(FLICK_START_X, FLICK_START_Y + FLICK_DISTANCE, FLICK_START_X, FLICK_START_Y)\n            # 遍历每条状态\n            for item in items:              \n                try:\n                    # 昵称\n                    nickname = self.wait.until(\n                EC.presence_of_all_elements_located(\n                    (By.XPATH,'//android.widget.FrameLayout[@content-desc=\"当前所在页面,朋友圈\"]/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.view.ViewGroup/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.RelativeLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.ListView/android.widget.FrameLayout[1]/android.widget.LinearLayout/android.widget.RelativeLayout/android.widget.TextView'))).text()\n                    # 正文\n                    content = self.wait.until(\n                EC.presence_of_all_elements_located(\n                    (By.XPATH,'//android.widget.FrameLayout[@content-desc=\"当前所在页面,朋友圈\"]/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.view.ViewGroup/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.RelativeLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.ListView/android.widget.FrameLayout[1]/android.widget.LinearLayout/android.widget.LinearLayout[1]/android.widget.LinearLayout/android.view.View'))).text()\n                    # 日期\n                    date = self.wait.until(\n                EC.presence_of_all_elements_located(\n                    (By.XPATH,'//android.widget.FrameLayout[@content-desc=\"当前所在页面,朋友圈\"]/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.view.ViewGroup/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.RelativeLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.ListView/android.widget.FrameLayout[1]/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.LinearLayout/android.widget.TextView'))).text()\n                    # 处理日期\n                    date = self.processor.date(date)\n                    print('一次insert记录')\n                    print(nickname, content, date)\n                    data = {\n                        'nickname': nickname,\n                        'content': content,\n                        'date': date,\n                    }\n                    # 插入MongoDB\n                    self.collection.update({'nickname': nickname, 'content': content}, {'$set': data}, True)\n                    sleep(SCROLL_SLEEP_TIME)\n                except NoSuchElementException:\n                    pass\n    \n    def main(self):\n        \"\"\"\n        入口\n        :return:\n        \"\"\"\n        # 登录\n        self.login()\n        # 进入朋友圈\n        self.enter()\n        # 爬取\n        self.crawl()\n\n\nif __name__ == '__main__':\n    moments = Moments()\n    moments.main()\n\n```\n\n\n\n对朋友圈时间进行处理\n\n```python\nimport time\nimport re\n\n\nclass Processor():\n    def date(self, datetime):\n        \"\"\"\n        处理时间\n        :param datetime: 原始时间\n        :return: 处理后时间\n        \"\"\"\n        if re.match('\\d+分钟前', datetime):\n            minute = re.match('(\\d+)', datetime).group(1)\n            datetime = time.strftime('%Y-%m-%d', time.localtime(time.time() - float(minute) * 60))\n        if re.match('\\d+小时前', datetime):\n            hour = re.match('(\\d+)', datetime).group(1)\n            datetime = time.strftime('%Y-%m-%d', time.localtime(time.time() - float(hour) * 60 * 60))\n        if re.match('昨天', datetime):\n            datetime = time.strftime('%Y-%m-%d', time.localtime(time.time() - 24 * 60 * 60))\n        if re.match('\\d+天前', datetime):\n            day = re.match('(\\d+)', datetime).group(1)\n            datetime = time.strftime('%Y-%m-%d', time.localtime(time.time()) - float(day) * 24 * 60 * 60)\n        return datetime\n```\n\n\n\n\n\n---未完待续\n\n\n\n\n\n\n\n\n\n","tags":["爬虫"]},{"title":"MongoDB","url":"/2018/10/20/MongoDB/","content":"\n*什么是MongoDB?我们又该去怎样使用它？*\n\n<!--more-->\n\n`已删`\n\n[MongoDB官方文档](https://www.runoob.com/mongodb)\n\n[PyMongo是在Python环境下使用MongoDB的语言](https://blog.csdn.net/callinglove/article/details/45668673?utm_source=blogxgwz0)\n\n写了一半，忽然觉得，针对 那些[工具性的]，就老老实实把官方的文档看懂。\n\n\n\n\n\n\n\n","tags":["工具"]},{"title":"写在学习代理池和cookie池之后","url":"/2018/10/08/sougoupachong/","content":"\n有关基本思路的描述\n\n <!--more-->\n\n这篇博客的目的是，尝试搞懂我最近做了什么.\n\n我们为什么要用代理池？<br>\n\n```\n部分网站有反爬虫措施，当我们使用一个ip地址对该网站进行过多的访问时，会被反爬虫机制自动视为爬虫，从而ip拉黑.\n```\n\n代理池的构建是怎样的？<br>\n\n```\n对网上的免费ip代理网站进行爬取(西刺，proxy360)，它们网站的ip源是完全暴露在网页源码上的，我们只用简单的进行分析，就可以拿到足够的ip.\n```\n\n如此一来，思路很清晰，设计一个爬虫，针对几个免费的网站解析爬取，将拿到 ip 进行筛选，排名，存入数据库。  并可以实现获取接口，即调即用。\n\n`基本模块分为 4块：存储模块、获取模块、检测模块、接口模块`\n\n###\n\n1. 存储模块： 负责存储抓取下来的代理。 首先要保证代理不重复， 要标识代理的可用情况，还 要动态实时处理每个代理，所以一种比较高效和方便的存储方式就是使用 Redis 的 Sorted Set，即有序集合。\n\n2. 获取模块： 需要定时在各大代理网站抓取代理。 代理可以是免费公开代理也可以是付费代 理，代理的形式都是 IP 加端口，此模块尽量从不同来源获取，尽量抓取高匿代理，抓取成功 之后将可用代理保存到数据库中。 \n\n3. 检测模块： 需要定时检测数据库中的代理。 这里需要设置一个检测链接，最好是爬取哪个网 站就检测哪个网站，这样更加有针对性，如果要做一个通用型的代理，那可以设置百度等链 接来检测。 另外，我们需要标识每一个代理的状态，如设置分数标识， 100 分代表可用，分 数越少代表越不可用。 检测一次，如果代理可用，我们可以将分数标识立即设置为 100 满 分，也可以在原基础上加 l分；如果代理不可用，可以将分数标识减 l 分，当分数戚到一定阔 值后，代理就直接从数据库移除。 通过这样的标识分数，我们就可以辨别代理的可用情况， 选用的时候会更有针对性。 \n\n4. 接口模块： 需要用 API 来提供对外服务的接口 。 其实我们可以直接连接数据库采取对应的数 据，但是这样就需要知道数据库的连接信息，并且要配置连接，而比较安全和方便的方式就 是提供一个 Web API 接口，我们通过访问接口即可拿到可用代理。 另外，由于可用代理可能 有多个，那么我们可以设置一个随机返回某个可用代理的接口，这样就能保证每个可用代理 都可以取到，实现负载均衡\n\n![](http://ww1.sinaimg.cn/large/006YPp6gly1fw7uv32bfaj30px0cfahk.jpg)\n\n[我们需要自己造轮子吗](https://github.com/Python3WebSpider/ProxyPool)  我觉得这要分情况。 \n\n<br><br>\n\n我们为什么要使用cookie池\n\n```\ncookies是我们登陆一个页面的接口，不登陆固然可以获取网页源码，但是会受访问限制，以及不具有一些页面的权限，比如微博来说，我们的cookie池实际上就是多个微博账号的信息。\n```\n\n与上面ip池的搭建差别是一些微博账号是我们需要自己通过某些渠道购买的。\n\n[轮子](https://github.com/Python3WebSpider/CookiesPool)\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["爬虫"]},{"title":"python の __new__()","url":"/2018/10/07/python_new/","content":"\n`在学习代理池中，发现了自己搁置的问题。我尝试通过这篇文章，来理清   __ new __  () 和 __ init __()的关系.`\n\n <!--more-->\n\n\n\n```python\n# coding:utf-8\n\n\nclass Foo(object):\n    price = 50\n\n    def how_much_of_book(self, n):\n        print(self)\n        return self.price * n\n\nfoo = Foo()\nprint(foo.how_much_of_book(8))\nprint(dir(Foo))\n```\n\n⬆⬆⬆分析上面的代码，这个类实例化过程，Foo类继承object类，继承了object的__new__方法。当你没有重载这个方法(通俗来说，`你没有在Foo类中没有写__new__方法)`，Foo实例化是默认自动调用父类__new__方法，这个方法返回值为类的实例，也就是self, 用来提供这个函数的第一个参数。\n\n```python\n# coding:utf-8\n\n\nclass Foo(object):\n    price = 50\n\n    def __new__(cls, *agrs, **kwds):\n        inst = object.__new__(cls, *agrs, **kwds)\n        print(inst)\n        return inst\n\n\n    def how_much_of_book(self, n):\n        print(self)\n        return self.price * n\n\nfoo = Foo()\nprint(foo.how_much_of_book(8))\n# <__main__.Foo object at 0x1006f2750>\n# <__main__.Foo object at 0x1006f2750>\n# 400\n```\n\n⬆⬆⬆请看上面代码，Foo类中重载了__new__方法，它的返回值为Foo类的实例对象\n\n___\n\n\n\n`_init__ 方法为初始化方法，为类的实例提供一些属性或完成一些动作`\n\n```python\n# coding:utf-8\n\n\nclass Foo(object):\n\n    def __new__(cls, *agrs, **kwds):\n        inst = object.__new__(cls, *agrs, **kwds)\n        print(inst)\n        return inst\n\n\n    def __init__(self, price=50):\n        self.price = price\n\n    def how_much_of_book(self, n):\n        print(self)\n        return self.price * n\n\nfoo = Foo()\nprint(foo.how_much_of_book(8))\n\n# <__main__.Foo object at 0x1006f2750>\n# <__main__.Foo object at 0x1006f2750>\n# 400\n```\n\n\n\n那么说到这里，我们用两句话来总结就是:\n\n⭐__new__ 方法创建实例对象供__init__ 方法使用，__init__方法定制实例对象。\n\n__⭐new__ 方法必须返回值，__init__方法不需要返回值。(如果返回非None值就报错)\n\n</br></br>\n\n我们举两个例子，观察New的常见两种用法\n\n第一： 继承不可变数据类型时需要用到__new__方法(like int, str, or tuple） \n\n 将英寸转化成米\n\n```\n# coding:utf-8\n\n\nclass Inch(float):\n    \"Convert from inch to meter\"\n    def __new__(cls, arg=0.0):\n        return float.__new__(cls, arg*0.0254)\n\nprint(Inch(12))\n```\n\n</br>\n\n第二:   用在元类，定制创建类对象\n\n```python\n# coding:utf-8\n'''来自http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example'''\n\nclass MetaClass(type):\n\n    def __new__(meta, name, bases, dct):\n        print '-----------------------------------'\n        print \"Allocating memory for class\", name\n        print meta\n        print bases\n        print dct\n        return super(MetaClass, meta).__new__(meta, name, bases, dct)\n\n    def __init__(cls, name, bases, dct):\n        print '-----------------------------------'\n        print \"Initializing class\", name\n        print cls\n        print bases\n        print dct\n        super(MetaClass, cls).__init__(name, bases, dct)\n\n\nclass Myclass(object):\n    __metaclass__ = MetaClass\n\n    def foo(self, param):\n        print param\n\n\np = Myclass()\np.foo(\"hello\")\n\n# -----------------------------------\n# Allocating memory for class Myclass\n# <class '__main__.MetaClass'>\n# (<type 'object'>,)\n# {'__module__': '__main__', 'foo': <function foo at 0x1007f6500>, '__metaclass__': <class '__main__.MetaClass'>}\n# -----------------------------------\n# Initializing class Myclass\n# <class '__main__.Myclass'>\n# (<type 'object'>,)\n# {'__module__': '__main__', 'foo': <function foo at 0x1007f6500>, '__metaclass__': <class '__main__.MetaClass'>}\n# hello\n```\n\n`Myclass相当于 拷贝了 MetaClass 的方法，MetaClass 的种类仍然是 MetaClass，定制的init 的种类 也自然是Myclass`","tags":["工具"]},{"title":"关于海","url":"/2018/10/07/photo/","content":"![](https://wx4.sinaimg.cn/mw690/6c3e6b13gy1fvyja7cikaj20uk0kedj0.jpg)\n<!--more-->\n![](https://wx3.sinaimg.cn/mw690/006lRDaTgy1fw2apaw5nlj32ro1ugnpe.jpg)\n</br>\n</br>\n<!--more-->","tags":["话"]},{"title":"GEETEST滑动验证码破解","url":"/2018/10/04/huadongpojie/","content":"验证码的破解，是网站爬虫正常运行所必须具备的功能。\n\n<!--more-->   \n 注: 本文针对[*滑动验证被切割随机打乱，并根据源码中 **< DIV >** 标签顺序进行 **取块排列**  验证情况 ，属于常见的一种混淆方式*]\n\n___\n\n关键词：\n\n1. **<a href=\"#1\" target=\"_self\">图像分析</a>**\n2. **<a href=\"#2\" target=\"_self\">图像拼接</a>**\n\n\n<p id=\"1\"><br>图像分析:</p>\n\n\n   &nbsp;&nbsp; 我们以[虎嗅网](https://www.huxiu.com/)登陆页面为例，我们在输入手机注册前，需要通过一个滑动式的 *captcha* ,我们可以通过`webdriver.chrome  + selenium` 来模拟拖动，问题就在于究竟要拖动多远？拖动的距离究竟是多少？(offset 究竟是多少？)\n\n\n![这是截图](http://ww1.sinaimg.cn/large/006YPp6gly1fvxl234pokj30dg07w76i.jpg)\n\n   &nbsp;&nbsp;仔细一想，如果有一个不存在缺口的**源图片**，那就舒服了，因为那样的话，我们只需比较，`源图哪些像素块，比上面的图形颜色更深，从而判断出深颜色缺口的位置`,这样我们就得到了，需要模拟拖动的距离了。那么从哪里可以得到原始图片呢？\n   F12审查代码时，发现了这样两个< div>:\n\n![黄线标出](http://ww1.sinaimg.cn/large/006YPp6gly1fvxku4epdej31620ew0uu.jpg)\n\n我们打开后发现，里面图片链接全部指向各自的那一个图片，[一个长这样](http://ww1.sinaimg.cn/large/006YPp6gly1fvxkuhcc8ij31630iq41p.jpg),[一个长这样](http://ww1.sinaimg.cn/large/006YPp6gly1fvxkxx3xzuj30kc0doabb.jpg),这，这！这不就是有缺口和没缺口的图片吗？\n<p id=\"2\"> <br><br> 图像拼接:</p>\n等等，为什么乱了？\n\n对，如果我们仔细观察，我们发现图片是被切割打乱了的，而且，我们判断，如果想得到原图，一定是要像拼积木一样把这些小块重新排列组合,那么，有什么规律在其中呢？我们该怎样一个一个拼呢？\n其实，不难发现，我们在打开那两个标签后，我们发现一些整整齐齐的从上到下的标签，并且还有   `position`属性，x,值以12为差，最小1 最大 277，但y只有 0 或 58，由此分析出，从上到下，是我们取积木的顺序，取打乱图的第一个(x,y)坐标点对应处的一块积木，然后拼接到一个空白框的左上角，然后接着从乱图里面取出第二个位置的积木，紧挨着刚才那一个向右，此行满了换下一行，以此类推,最终得到一个完整图。\n这样的话，我们的分析就结束了，然后我们通过像素比较就可以找出，缺口的位置，然后模拟拖动就ok了。\n注意，实际应用中，我们需要实验性模拟拖动几次，再对拖动距离distance进行微修正，从而提高准确率。\n<br><br>\n[源码](https://paste.ubuntu.com/p/y7PSVFdxsJ/)\n<br>\n[参考博客](https://www.jianshu.com/p/c8df1194b514)","tags":["爬虫"]},{"title":"快速熟悉 markdown","url":"/2018/10/02/learn_MarkDown/","content":"*快速熟悉*        \n   ***markdown***\n\n<!--more-->        \n___\n>我们可以使用  **大于号** ，来表示引用\n\n~~我们在文本两边，加上一对双波浪号，就得到删除特效~~\n\n[方框内部是文本,点击跳转百度](http://www.baidu.com)\n![如果框起前面加个感叹号，代表我要加图片图片](http://ww1.sinaimg.cn/large/006YPp6gly1fvu4hphapdj307g08edh6.jpg)\n倘若我先写三个井号，代表我要开始**列表**，*、+号带领无序，1.带领有序\n###\n* k1\n* k2\n* k3\n1. l1\n2. l2\n3. l3\n###\n一对反引号可以生成一个`背景加深`，这很讨喜\n且表格的创建，格外方便，只用添加一点  |:----: |这表明，我正在写表格\n|电影|导演|评分|\n|:----:|:----:|:----:|\n|天注定|贾樟柯|未知|\n|江湖儿女|贾樟柯|未知|\n|三峡好人|贾樟柯|未知|\n|站台|贾樟柯|未知|\n\n\n我们规定用三个反引号括住代码块\n```\nconst unsigned long int a ;\na = inf ;\n```\n[点击查看源码图](http://ww1.sinaimg.cn/large/006YPp6gly1fvu792e3vuj30wx0npmz5.jpg)\n[点击查看效果图](http://ww1.sinaimg.cn/large/006YPp6gly1fvu6opl5ytj30j80ofagp.jpg)","tags":["工具"]},{"title":"Hexo 更换主题","url":"/2018/09/29/newtheme/","content":"\n简短的关于Hexo主题更新配置的说明\n当你需要更换自己的博客主题时，你需要这样做：\n <!--more-->\n```\n\n\n$ git clone https://*********\n$ npm install hexo-renderer-pug --save\n$ npm install hexo-renderer-sass --save   #下载主题文件和渲染器，如果在下载第三个文件的过程中报错，你可以试试npm国内镜像，或科学上网。\n\ntheme: ****        #打开根目录下的_config.yml,并找到 theme关键字，更新自己主题名称\n$ hexo clean\n$ hexo g           # 生成静态页面\n$ hexo d           # 上传到github\n```\n\n\n","tags":["工具"]}]